#!/bin/bash

########## buildseqmap.sh
# Description:
#  create seqmap files for give pdb chains or scop domain sequences
# =======================================
# format of the seqmap file
# ID: d12asa_
# sequence length: 327
# AA       -- one-letter amino acid
# seqidx   -- sequence index for the sequence in pdb_seqres.txt, starting from 1
# resser   -- index of the residue in the pdb file, 
#             -999 means the residue exists in the sequence, but not exists in ATOM record
# icode    -- pdb insertion code for the residue, '.' means icode is blank
# shape    -- 8-state shape symbol, '-' means shape symbol is not availble
# waterAcc -- water accessibility from DSSP, '-1' means water accessibility is not availble
# dsspSec  -- secondary structure symbol in DSSP, '-' means secondary structure is not availble
#             'R' means random coil, which is blank in DSSP
# AA seqidx resser icode shape waterAcc dsspSec
# A       1      4     .     -      97       R
# Y       2      5     .     A      20       H
# I       3      6     .     A      69       H
# A       4      7     .     A      48       H
#
# ======================================
# Prerequisites:
#  PDB files and sequence files in fasta format should be available
#  
#  if DSSP files are missing, it will be generated by the program dssp
#    W. Kabsch, C. Sander and MPI-MF, 1983, 1985, 1988, 1994 1995
#    CMBI version by Elmar.Krieger@cmbi.kun.nl / November 18,2002
# 
# CopyrightÂ© Nanjiang Shu 
# Department of Materials and Environmental Chemistry, Stockholm University,
# Sweden
# Email: nanjiang.shu@mmk.su.se
# 

usage="
Usage:  buildseqmap.sh ids  --pdbaa pdbaapath
    Build the seqmap files given ids
    The PDB files of the input ids should be available
Options:
  -l|--list       : set idListFile
  --output path   : set ouput path, default = ./
  --pdbaa         : path storing fasta files
  --dssp          : path storing dssp files, default=$DATADIR/dssp
  --pdb           : path storing pdb files, default=$DATADIR/pdb_dcp
  --not-clean|-nc : do not clean temporary files
  -h|--help       : print this help message and exit
Created 2010-01-12, updated 2011-03-17, Nanjiang Shu

Examples:
    buildseqmap.sh -l idlist.txt --pdbaa pdbaapath
"
function PrintHelp()
{
    echo "$usage"
}
function FilterIDList()#{{{
{
    local tmplist=$(mktemp /tmp/tmp.XXXXXXXXXX) || { echo "Failed to create temp file"; exit 1; }
    local aafile=
    (for id in $(cat $idListFile);do
        aafile=$pdbaaPath/$id.aa
        if [ ! -f  "$aafile" ]; then
            echo "The sequence file for id \"$id\" ($aafile) does not exist, it will be neglected" >&2
        else
            echo $id
        fi
    done) > $tmplist
    idListFile=$tmplist
}
#}}}
function IsProgExist()#{{{
# usage: IsProgExist prog
# prog can be both with or without absolute path
{
    type -P $1 &>/dev/null || { echo "The program \"$1\" is required but it's not installed. Aborting." >&2; exit 1; }
}
#}}}
function IsPathExist()#{{{
# supply the effective path of the program 
{
    if ! test -d $1; then
        echo "directory $1 does not exist, exit." >&2
        exit
    fi
}
#}}}
function AddPath_head() # $newItem $PATH #{{{
# usage: newpath=`AddPath_head $newItem $PATH` 
# add newItem to the beginning of PATH variable
{
    local newItem="$1"
    local oldPath="$2"
    local separator=:

    local existence="`echo "$oldPath" | grep "$newItem"`"
    local newPath=
    if [ "$existence" == "" ]; then
        newPath="${newItem}${separator}${oldPath}"
    else
        newPath="${oldPath}"
    fi
    echo "$newPath"
}
#}}}
function AddAbsolutePath() #$path#{{{
{
    local var=$1
    if [ "${var:0:1}" != "/" ];then
        var=$PWD/$var # add the absolut path
    fi
    echo $var
    return 0
}
#}}}
function CheckErrMsg() #$errFile
{
    local errFile=$1
    if [ -s "$errFile" ]; then 
        cat $errFile >&2
        exit
    fi
}

if [ $# -lt 1 ]; then 
    PrintHelp
    exit
fi

BUILDSEQMAP=`dirname $0` #changed date 2011-03-15
BUILDSEQMAP=`AddAbsolutePath $BUILDSEQMAP`
LD_LIBRARY_PATH=`AddPath_head "$BUILDSEQMAP/lib" "$LD_LIBRARY_PATH"` 
export BUILDSEQMAP
export LD_LIBRARY_PATH

binpath=$BUILDSEQMAP/bin
shapestringrawdata=$BUILDSEQMAP/data/shapestring/rawdata

dsspPath=$DATADIR/dssp

isClean=true
outpath=./
pdbaaPath=
idListFile=

tmpDIR=$(mktemp -d /tmp/tmpdir.XXXXXX) || { echo "Failed to create temp dir"; exit 1; }  
tmpIDListFile=$tmpDIR/buildseqmap.idlist

isNonOptionArg=false
while [ "$1" != "" ]; do
    if [ "$isNonOptionArg" == "true" ]; then 
        if [ ! -d "$tmpDIR" ]; then
            mkdir -p $tmpDIR
        fi
        echo "$1" >> $tmpIDListFile
        isNonOptionArg=false
    elif [ "$1" == "--" ]; then
        isNonOptionArg=true
    elif [ "${1:0:1}" == "-" ]; then
        case $1 in
            -h | --help) PrintHelp; exit;;
            --outpath|-outpath) outpath=$2;shift;;
            -pdbaa|--pdbaa) pdbaaPath=$2;shift;;
            -l|-list|--list) idListFile=$2;shift;;
            -nc|--not-clean)isClean=false;;
            -*) echo "Error! Wrong argument: $1"; exit;;
        esac
    else
        echo "$1" >> $tmpIDListFile
    fi
    shift
done

if [ "$idListFile" == "" ]; then 
    idListFile=$tmpIDListFile
fi

if [ ! -s "$idListFile" ]; then
    echo "input file $idListFile is empty" >&2
    exit
fi

if [ ! -d "$pdbaaPath" ] ; then
    echo "Error, pdbaaPath = $pdbaaPath does not exist, exit!" >&2
    exit
fi


IsProgExist  wc
IsProgExist /usr/bin/awk


errFile=$tmpDIR/buildseqmap.err

############# 0. check if all pdbaa files exist 
FilterIDList
##############
NID=`wc -l $idListFile | awk '{print $1}'`
echo
echo "Create seqmap files for $NID sequences"
echo
if [ $NID -lt 1 ]; then
    echo "The number of IDs is zero. No actions to be done. Exit..." >&2
    exit
fi

mkdir -p $outpath

$binpath/classify-seqid.awk -ltype -1 $idListFile > $errFile
if [ -s $errFile ]; then
    echo "The following ids are unrecognized, please check it "
    CheckErrMsg $errFile
fi

################  1. preparing data:
printf "1. Checking necessary data, e.g. PDB files, DSSP files ..."
## 1.1 check if PDB files exist for all input ids
tmpPDBIDListFile=$tmpDIR/buildseqmap.pdbidlist
tmpPDBFileListFile=$tmpDIR/buildseqmap.pdbfilelist
$binpath/id2pdbid.awk $idListFile | sort -u > $tmpPDBIDListFile

$binpath/getpdbfilepath -l $tmpPDBIDListFile 1> $tmpPDBFileListFile 2> $errFile
CheckErrMsg $errFile

## 1.2 check if all DSSP files exist, if not, use the program dssp to generate them from the PDB file
tmpDSSPFileListFile=$tmpDIR/buildseqmap.dsspfilelist 
$binpath/getdsspfilepath -l $tmpPDBIDListFile 1> $tmpDSSPFileListFile 2> $errFile
if [ -s "$errFile" ]; then
    tmpPDBIDWithoutDSSP=$tmpDIR/buildseqmap.withoutdssp.pdbidlist
    awk '{print $NF}' $errFile > $tmpPDBIDWithoutDSSP
    $binpath/createdssp.sh --idlist $tmpPDBIDWithoutDSSP -d $dsspPath > /dev/null 2>&1
fi

printf "done!\n"

############### 2 get shape strings

echo
echo "2. Creating shape string files"

shapePath=$tmpDIR/shapestring
mkdir -p $shapePath

tmpIDListFile=$tmpDIR/type0.idlist
$binpath/classify-seqid.awk -ltype 0 $idListFile > $tmpIDListFile #pdb chains
if [ -s $tmpIDListFile ]; then
    printf "Create shape string files for PDB chains ..."
    cShapeList=$tmpDIR/type0.cShape # cShapeList is used to be input in the program "shapestring" 
    shapestringFile=$tmpDIR/type0.shapestring
    echo
    echo "$binpath/cShapeStringList.sh -pdbaa $pdbaaPath -pdbaatype 1 $tmpIDListFile 1> $cShapeList 2> $errFile"
    $binpath/cShapeStringList.sh -pdbaa $pdbaaPath -pdbaatype 1 $tmpIDListFile 1> $cShapeList 2> $errFile
    CheckErrMsg $errFile

    echo "$binpath/shapestring -l $cShapeList > $shapestringFile"
    $binpath/shapestring --data $shapestringrawdata -l $cShapeList 1> $shapestringFile 2> $errFile
    CheckErrMsg $errFile

    echo "$binpath/splitfasta -d $shapePath -e shapestring $shapestringFile   1> /dev/null  2> $errFile"
    $binpath/splitfasta -d $shapePath -e shapestring $shapestringFile   1> /dev/null  2> $errFile
    CheckErrMsg $errFile
    printf "\n... done!\n"
fi

tmpIDListFile=$tmpDIR/type13.idlist
$binpath/classify-seqid.awk -ltype 13 $idListFile > $tmpIDListFile #single chain domain
if [ -s $tmpIDListFile ]; then
    printf "Create shape string files for SCOP single chain domains ...\n"
    tmpSTDIDListFile=$tmpDIR/stdid13.idlist
    tmpWholeChainPDBAAPath=$tmpDIR/wholeChainPDBAA
    mkdir -p $tmpWholeChainPDBAAPath
    $binpath/scopid2stdid.awk $tmpIDListFile > $tmpSTDIDListFile
    echo
    echo "$binpath/createpdbaa.sh $tmpSTDIDListFile -t 0 --idtype 1 -d $tmpWholeChainPDBAAPath 1> /dev/null 2> $errFile"
    $binpath/createpdbaa.sh $tmpSTDIDListFile -t 0 --idtype 1 -d $tmpWholeChainPDBAAPath 1> /dev/null 2> $errFile


    cShapeList=$tmpDIR/type13.cShape # cShapeList is used to be input in the program "shapestring" 
    shapestringFile=$tmpDIR/type13.shapestring

    echo "$binpath/cShapeStringList.sh -pdbaa $tmpWholeChainPDBAAPath -pdbaatype 1 $tmpSTDIDListFile 1> $cShapeList 2> $errFile"
    $binpath/cShapeStringList.sh -pdbaa $tmpWholeChainPDBAAPath -pdbaatype 1 $tmpSTDIDListFile 1> $cShapeList 2> $errFile
    CheckErrMsg $errFile

    echo "$binpath/shapestring -l $cShapeList 1> $shapestringFile 2> $errFile"
    $binpath/shapestring -l $cShapeList 1> $shapestringFile 2> $errFile
    CheckErrMsg $errFile

    echo "$binpath/splitfasta -d $shapePath -e shapestring $shapestringFile   1> /dev/null  2> $errFile"
    $binpath/splitfasta -d $shapePath -e shapestring $shapestringFile   1> /dev/null  2> $errFile
    CheckErrMsg $errFile
    printf "\n... done!\n"
fi

tmpIDListFile=$tmpDIR/type2.idlist
$binpath/classify-seqid.awk -ltype 2 $idListFile > $tmpIDListFile #single chain domain
if [ -s $tmpIDListFile ]; then
    printf "Create shape string files SCOP multiple doamin chains...\n"
    tmpPDBIDListFile=$tmpDIR/pdbid2.idlist
    tmpPDBFileListFile=$tmpDIR/pdbid2.pdbfilelist
    tmpWholeChainPDBAAPath=$tmpDIR/wholeChainPDBAA
    tmpPDBAAFile=$tmpDIR/wholeChain2.aa
    mkdir -p $tmpWholeChainPDBAAPath

    echo
    $binpath/id2pdbid.awk $tmpIDListFile | sort -u > $tmpPDBIDListFile

    echo "$binpath/getpdbfilepath  -l $tmpPDBIDListFile 1> $tmpPDBFileListFile 2> $errFile"
    $binpath/getpdbfilepath  -l $tmpPDBIDListFile 1> $tmpPDBFileListFile 2> $errFile
    CheckErrMsg $errFile

    echo "$binpath/getseqresseq  -l $tmpPDBFileListFile --idtype 1 > $tmpPDBAAFile 2> $errFile"
    $binpath/getseqresseq  -l $tmpPDBFileListFile --idtype 1 > $tmpPDBAAFile 2> $errFile
    CheckErrMsg $errFile

    echo "$binpath/splitfasta -d $tmpWholeChainPDBAAPath -e aa $tmpPDBAAFile   1> /dev/null  2> $errFile"
    $binpath/splitfasta -d $tmpWholeChainPDBAAPath -e aa $tmpPDBAAFile   1> /dev/null  2> $errFile
    CheckErrMsg $errFile

    tmpSTDIDListFile=$tmpDIR/stdid2.idlist
    find $tmpWholeChainPDBAAPath -name "*.aa" | rootname | sort -u > $tmpSTDIDListFile

    cShapeList=$tmpDIR/type2.cShape # cShapeList is used to be input in the program "shapestring" 
    shapestringFile=$tmpDIR/type2.shapestring
    echo "$binpath/cShapeStringList.sh -pdbaa $tmpWholeChainPDBAAPath -pdbaatype 1 $tmpSTDIDListFile 1> $cShapeList 2> $errFile"
    $binpath/cShapeStringList.sh -pdbaa $tmpWholeChainPDBAAPath -pdbaatype 1 $tmpSTDIDListFile 1> $cShapeList 2> $errFile
    CheckErrMsg $errFile

    echo "$binpath/shapestring -l $cShapeList 1> $shapestringFile   2> $errFile"
    $binpath/shapestring -l $cShapeList 1> $shapestringFile   2> $errFile
    CheckErrMsg $errFile

    echo "$binpath/splitfasta -d $shapePath -e shapestring $shapestringFile   1> /dev/null  2> $errFile"
    $binpath/splitfasta -d $shapePath -e shapestring $shapestringFile   1> /dev/null  2> $errFile
    CheckErrMsg $errFile

    printf "\n... done!\n"
fi

################## 3 create seqmap
logFile=$tmpDIR/createseqmap.log
echo 
echo "3. Create seqmap files"
echo "$binpath/createseqmap  -l $idListFile --aapath $pdbaaPath --shapepath $shapePath --outpath $outpath 1> $logFile 2> $errFile"
$binpath/createseqmap  -l $idListFile --aapath $pdbaaPath --shapepath $shapePath --outpath $outpath 1> $logFile 2> $errFile
NFinished=`wc -l $logFile | awk '{ print $1 }'`
Ncnt=0
while [ $NFinished -lt $NID ]; do 
    NFinished=`wc -l $logFile | awk '{ print $1 }'`
    if [ $NFinished -ge $Ncnt ]; then 
        printf "%d ...",$Ncnt 
        ((Ncnt+=100))
    fi
done
printf "\n...done!\n"

####### clean 
if [ "$isClean" == "true" ]; then
    echo
    echo "4. Clean temporary files"
    if [ -d "$tmpDIR" ]; then
        rm -rf $tmpDIR
    fi
    printf "...done!\n"
else
    echo "Temporary files are at $tmpDIR"
fi

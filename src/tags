!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.5.4	//
AA1To3	mypro.cpp	/^const char* AA1To3(char ch)\/*{{{*\/$/;"	f
AA3To1	mypro.cpp	/^char AA3To1(const char* aa3, int mode \/*= 0*\/)\/*{{{*\/$/;"	f
AAAlphabet_Tuping	mypro.cpp	/^const char AAAlphabet_Tuping[] = "AVLIPFMKRHGSTCYNEWDQ" ;$/;"	v
AASEQINDEX	mypro.h	84;"	d
AA_SEQ	myfunc.h	74;"	d
AAalphabet	shapestring.cpp	/^char AAalphabet[40] = "";$/;"	v
AAs	shapestring.cpp	/^const char *AAs[] = \/*{{{*\/$/;"	v
ALIGNMODE	mypro.h	88;"	d
AND	mypro.h	116;"	d
ASCENDING	myfunc.h	100;"	d
Aligment_Two_sequence_500	shapestring.cpp	/^int Aligment_Two_sequence_500(int *Seq1, int *Seq2, int Len1, int Len2, char *cseq1,char *cseq2, int *Align_Table,int *Max_Score)\/*{{{*\/$/;"	f
AlignAna	mypro.cpp	/^template <class T> void AlignAna(const int8* alignX, const int8* alignY, int length, T **subMatr, AlignFactor* pAlignFactor, int* alignRel)\/*{{{*\/$/;"	f
AlignAna_Profile	mypro.cpp	/^template <class T> void AlignAna_Profile(const int8* alignX, const int8* alignY, int length, T **M1, T **M2, T **log_M1, T **log_M2, AlignFactor* pAlignFactor, int* alignRel)\/*{{{*\/$/;"	f
AlignAna_Protein	mypro.h	246;"	d
AlignFactor	mypro.h	/^struct AlignFactor\/*{{{*\/$/;"	s
Alignment	mypro.cpp	/^template <class T> int Alignment(char *Xstr, char *Ystr, char *alphabet, int m, int n,char *title1,char* title2,  \/*{{{*\/ $/;"	f
Alignment_Profile	mypro.cpp	/^template <class T> int Alignment_Profile(char *Xstr, char *Ystr, T **M1, T **M2, T **log_M1, T **log_M2, char *alphabet, int m, int n,char *title1,char* title2,  \/*{{{*\/ $/;"	f
AllocGistPredChain	mypro.cpp	/^void AllocGistPredChain(GistPredChain * pChain, int size)\/*{{{*\/$/;"	f
AllocMODM	mypro.cpp	/^void AllocMODM(MODM *pMODM, int length, bool isAllocLogM \/*=false*\/, int sizeAlphabet \/*= NUM_BLOSUM*\/)\/*{{{*\/$/;"	f
Array1D	array.h	/^template <class T>  class Array1D \/\/ can be accessed both by .array1D and []$/;"	c
Array1D	array.h	/^template <class T> Array1D<T>::Array1D(unsigned int size)\/*{{{*\/$/;"	f	class:Array1D
Array2D	array.h	/^template <class T> Array2D<T>::Array2D(unsigned int rowSize, unsigned int colSize)$/;"	f	class:Array2D
Array2D	array.h	/^template <class T> class Array2D \/\/accessed by .array2D$/;"	c
Array2D_Sub	array.h	/^	Array2D_Sub(unsigned int rowSize,unsigned int colSize)$/;"	f	class:Array2D_Sub
Array2D_Sub	array.h	/^template <class T> class Array2D_Sub \/\/ can be accessed by [][]$/;"	c
Array3D	array.h	/^template <class T> Array3D<T>::Array3D(unsigned int xSize, unsigned int ySize, unsigned int zSize)\/*{{{*\/$/;"	f	class:Array3D
Array3D	array.h	/^template <class T> class Array3D \/\/accessed by .array3D$/;"	c
Atom	mypro.h	/^struct Atom \/\/define the structure for ATOM record in PDB file\/*{{{*\/$/;"	s
AtomEnv	mypro.h	/^struct AtomEnv  \/\/ environment of atoms, the residues within \/*{{{*\/$/;"	s
AtomFreq	mypro.h	/^struct AtomFreq\/*{{{*\/$/;"	s
AtomFrequencyAna_AtomEnv	mypro.cpp	/^void AtomFrequencyAna_AtomEnv(AtomEnv *atomEnvs, int numAtomEnv,Element *metalEle, int numMetalEle, char *str) \/*{{{*\/ $/;"	f
Average	mytemplate.h	/^template <class T> double Average(T *array, int low, int high)\/*{{{*\/$/;"	f
BLOSUM1D_alphabet	mypro.cpp	/^const char BLOSUM1D_alphabet[] = "ARNDCQEGHILKMFPSTWYVBZX*";$/;"	v
BLOSUM3D_alphabet	mypro.cpp	/^const char *BLOSUM3D_alphabet[] = \/*{{{*\/$/;"	v
BOOL	DataType.h	/^typedef int                 BOOL;$/;"	t
BYTE	DataType.h	/^typedef unsigned char       BYTE;$/;"	t
Background_AA_Freq	mypro.cpp	/^const double Background_AA_Freq[] = { 0.078, 0.051, 0.045, 0.054, 0.019, 0.043, 0.063, 0.074, 0.022, 0.052, 0.09,0.057, 0.022, 0.039, 0.052, 0.071, 0.059, 0.013, 0.032, 0.064 } ; \/\/ ordered by BLOSUM1D_alphabet, from sdsc$/;"	v
BinarySearch_String	myfunc.cpp	/^template <class T> int BinarySearch_String(T keyStr, T* strs, int n) \/*{{{*\/$/;"	f
BitSwap	myfunc.cpp	/^int BitSwap(int i, int pow2)\/*{{{*\/$/;"	f
BubbleSort	myfunc.cpp	/^void BubbleSort(int* a, int n)\/*{{{*\/$/;"	f
CHAR_DNA	mypro.h	131;"	d
CHAR_INDEL	mypro.cpp	/^char CHAR_INDEL = '-' ;\/\/ character representation of insertion and deletion$/;"	v
CHAR_NON_RESIDUE	mypro.h	132;"	d
CHAR_VECTOR_ID_SEPRATOR	mypro.cpp	/^char CHAR_VECTOR_ID_SEPRATOR =  ';'; \/\/the separator for items in the record id of svm vectors$/;"	v
CLUSTALW	mypro.h	45;"	d
CP	Makefile	/^CP = \/bin\/cp -f $/;"	m
CalLogM	mypro.cpp	/^template <class T> void CalLogM(T **M, T **log_M, int xSize, int ySize,  double roundoff_scale \/* = 1.0*\/)\/*{{{*\/$/;"	f
Calculate_torsion_angles_phi_psi	shapestring.cpp	/^double Calculate_torsion_angles_phi_psi(double *point1,double *point2,double *point3,double *point4)\/*{{{*\/$/;"	f
Chain	mypro.h	/^struct Chain \/\/data structure for one chain of a protein \/*{{{*\/$/;"	s
Char2Digit	myfunc.cpp	/^int Char2Digit(char aa, const char* alphabet, int n\/* = 0*\/)\/*{{{*\/$/;"	f
CharToDigit_Protein	mypro.cpp	/^void CharToDigit_Protein(const char* str, int8* a,int n)\/*{{{*\/$/;"	f
Charcase2Digit	myfunc.cpp	/^int Charcase2Digit(char aa, const char* alphabet, int n \/*= 0*\/)\/*{{{*\/$/;"	f
Complex	DataType.h	/^}Complex;$/;"	t
Compute_ROC50_score	myfunc.cpp	/^double Compute_ROC50_score(int* label, int n)\/*{{{*\/$/;"	f
Compute_ROC_score	myfunc.cpp	/^double Compute_ROC_score(int* label, int n)\/*{{{*\/$/;"	f
Compute_medianRFP50_score	myfunc.cpp	/^double Compute_medianRFP50_score(int* label, double* score, int n)\/*{{{*\/$/;"	f
Compute_medianRFP_score	myfunc.cpp	/^double Compute_medianRFP_score(int* label, double* score, int n)\/*{{{*\/$/;"	f
CopyAtom	mypro.cpp	/^void CopyAtom(Atom* to, Atom* from)\/*{{{*\/$/;"	f
CopyAtomEnv	mypro.cpp	/^void CopyAtomEnv(AtomEnv *pAtomEnv1, AtomEnv *pAtomEnv2, bool isCopyResidue \/*= true*\/)\/*{{{*\/$/;"	f
CopyAtomFreq	mypro.cpp	/^void CopyAtomFreq(AtomFreq *to, AtomFreq *from)\/*{{{*\/$/;"	f
CopyChain	mypro.cpp	/^void CopyChain(Chain * to, Chain * from)\/*{{{*\/$/;"	f
CopyGistPredChain	mypro.cpp	/^void CopyGistPredChain(GistPredChain *to, GistPredChain *from)\/*{{{*\/$/;"	f
CopyMODM	mypro.cpp	/^void CopyMODM(MODM *to, MODM *from)\/*{{{*\/$/;"	f
CopyMetalPro	mypro.cpp	/^void CopyMetalPro(MetalPro *pMetalPro1, MetalPro *pMetalPro2, bool isCopyResidue\/* = true*\/)\/*{{{*\/$/;"	f
CopyMetalPro	mypro.cpp	/^void CopyMetalPro(MetalPro2 *pMetalPro1, MetalPro2 *pMetalPro2, bool isCopyAtomEnv \/*= true*\/)\/*{{{*\/$/;"	f
CopyPredPro	mypro.cpp	/^void CopyPredPro(PredPro *pPredPro1, PredPro *pPredPro2)\/*{{{*\/$/;"	f
CopyResidue	mypro.cpp	/^void CopyResidue(Residue* to,Residue* from)\/*{{{*\/$/;"	f
CopySCOP	mypro.cpp	/^void CopySCOP(SCOP* to, SCOP* from)\/*{{{*\/$/;"	f
CopySSBond	mypro.cpp	/^void CopySSBond(SSBond *to, SSBond *from, bool isCopyResidue \/*= true*\/)\/*{{{*\/$/;"	f
CopySSBondPro	mypro.cpp	/^void CopySSBondPro(SSBondPro *to, SSBondPro *from, bool isCopySSBond \/*= true*\/)\/*{{{*\/$/;"	f
Coverage	mytemplate.h	/^template <class T> T Coverage(T a1, T b1, T a2, T b2)\/*{{{*\/$/;"	f
Create2DArray	array.h	/^template <class T> T **Create2DArray(T **array, unsigned int xSize, unsigned int ySize)\/*{{{*\/$/;"	f
Create3DArray	array.h	/^template <class T> T*** Create3DArray(T ***array, unsigned int xSize, unsigned int ySize, unsigned int zSize)\/*{{{*\/$/;"	f
CreateDSSP	createdssp.sh	/^function CreateDSSP() # pdbfile num pdbid#{{{$/;"	f
CreateSeqMap	createseqmap.cpp	/^int CreateSeqMap(char* id, char chainID, const char* outpath, FILE * fpAlign, FILE *fpLog, int cnt ,  int idtype, const char *pdbaapath, const char *shapestringpath, char *seqmapfile)\/*{{{*\/$/;"	f
CreateSeqMap_SCOPg	createseqmap.cpp	/^int CreateSeqMap_SCOPg(char* scopid, char* chainIDList, const char* outpath, FILE * fpAlign, FILE *fpLog, int cnt ,  int idtype, const char *pdbaapath, const char *shapestringpath, char *seqmapfile)\/*{{{*\/$/;"	f
DATATYPE_CONSV	mypro.h	23;"	d
DATATYPE_MODM_MATRIX	mypro.h	19;"	d
DATATYPE_SMATRIX	mypro.h	27;"	d
DESCENDING	myfunc.h	101;"	d
DIAG	mypro.h	99;"	d
DIGIT_INDEL	mypro.cpp	/^int DIGIT_INDEL = -9;$/;"	v
DNA_SEQ	myfunc.h	73;"	d
DSSP_HBond	mypro.h	/^struct DSSP_HBond\/*{{{*\/$/;"	s
DSSP_Residue	mypro.h	/^struct DSSP_Residue\/*{{{*\/$/;"	s
DSSP_SEC_RANDOM	mypro.h	130;"	d
D_LIBRARY_PATH	Makefile	/^export LD_LIBRARY_PATH := ..\/lib$/;"	m
Delete2DArray	array.h	/^template <class T> void Delete2DArray(T **array, unsigned int xSize)\/*{{{*\/$/;"	f
Delete3DArray	array.h	/^template <class T> void Delete3DArray(T ***array, unsigned int xSize, unsigned int ySize)\/*{{{*\/$/;"	f
DeleteAtom	mypro.cpp	/^void DeleteAtom(Atom *pAtom)\/*{{{*\/$/;"	f
DeleteAtomEnv	mypro.cpp	/^void DeleteAtomEnv(AtomEnv *pAtomEnv, int numRes  \/*= 0*\/, int numAtom_Res \/*= 0*\/ )\/*{{{*\/$/;"	f
DeleteChain	mypro.cpp	/^void DeleteChain(Chain *pChain)\/*{{{*\/$/;"	f
DeleteGistPredChain	mypro.cpp	/^void DeleteGistPredChain(GistPredChain *pChain)\/*{{{*\/$/;"	f
DeleteMODM	mypro.cpp	/^void DeleteMODM(MODM *pMODM, int length)\/*{{{*\/$/;"	f
DeleteMSA	mypro.cpp	/^void DeleteMSA(MSA *pMSA)\/*{{{*\/$/;"	f
DeleteMetalPro	mypro.cpp	/^void DeleteMetalPro(MetalPro *pMetalPro, int numMetalAtom \/*= 0*\/, int numBoundRes \/* = 0*\/)\/*{{{*\/$/;"	f
DeleteMetalPro	mypro.cpp	/^void DeleteMetalPro(MetalPro2 *pMetalPro, int numMetalAtom \/*= 0*\/)\/*{{{*\/$/;"	f
DeletePredPro	mypro.cpp	/^void DeletePredPro(PredPro *pPredPro)\/*{{{*\/$/;"	f
DeleteResidue	mypro.cpp	/^void DeleteResidue(Residue *pRes, int numAtom \/*= 0 *\/)\/*{{{*\/$/;"	f
DeleteSSBondPro	mypro.cpp	/^void DeleteSSBondPro(SSBondPro *pSSBondPro)\/*{{{*\/$/;"	f
DetectChainID	createseqmap.cpp	/^int DetectChainID(char *id, char* chainIDList, int idtype )\/*{{{*\/$/;"	f
DetectIDType	createseqmap.cpp	/^int DetectIDType(char *id)\/*{{{*\/$/;"	f
Digit2Char	myfunc.cpp	/^int Digit2Char(int dc, const char* alphabet, int n \/*= 0*\/)\/*{{{*\/$/;"	f
DigitAA	mypro.cpp	/^int DigitAA(char* resName)\/*{{{*\/$/;"	f
DigitShape	mypro.cpp	/^int DigitShape(char shape)\/*{{{*\/$/;"	f
DigitToChar_Protein	mypro.cpp	/^void DigitToChar_Protein(const int8 *a, int n, char* str)\/*{{{*\/$/;"	f
DomainDEF	mypro.h	/^struct DomainDEF\/*{{{*\/ \/\/\/\/ parsered domain definition, e.g. A:1-32,A:35-140 $/;"	s
E	Constant.h	83;"	d
ENCODING_TYPE	mypro.h	38;"	d
Element	mypro.h	/^struct Element \/\/define the structure for chemical element\/*{{{*\/$/;"	s
EncodeMatrixAA_Center	mypro.cpp	/^int EncodeMatrixAA_Center[][SIZE_ENCODE_AA_CENTER] =$/;"	v
EncodeMatrixAA_Center_alphabet	mypro.cpp	/^char EncodeMatrixAA_Center_alphabet[] = "CHDE";$/;"	v
EncodeMatrixAA_Non_Center	mypro.cpp	/^int EncodeMatrixAA_Non_Center[][SIZE_ENCODE_AA_NON_CENTER] =$/;"	v
EncodeMatrixAA_Non_Center_alphabet	mypro.cpp	/^char EncodeMatrixAA_Non_Center_alphabet[] = "CHDE";$/;"	v
EncodeMatrixDistance	mypro.cpp	/^int EncodeMatrixDistance[][SIZE_ENCODE_DISTANCE] =$/;"	v
EncodeMatrixHydrophobicity	mypro.cpp	/^int EncodeMatrixHydrophobicity[][SIZE_ENCODE_HYDROPHOBICITY] =$/;"	v
EncodeMatrixScore1	mypro.cpp	/^int EncodeMatrixScore1[][SIZE_ENCODE_SCORE1] =$/;"	v
EncodeMatrixScore2	mypro.cpp	/^int EncodeMatrixScore2[][SIZE_ENCODE_SCORE2] = $/;"	v
EncodeMatrixWaterAcc	mypro.cpp	/^int EncodeMatrixWaterAcc[][SIZE_ENCODE_WATERACC] =$/;"	v
EncodeScaleDistance	mypro.cpp	/^int EncodeScaleDistance[] =$/;"	v
EncodeScaleHydrophobicity	mypro.cpp	/^double EncodeScaleHydrophobicity[] =                          $/;"	v
EncodeScaleScore1	mypro.cpp	/^double EncodeScaleScore1[] =$/;"	v
EncodeScaleScore2	mypro.cpp	/^double EncodeScaleScore2[] =$/;"	v
EncodeScaleWaterAcc	mypro.cpp	/^int EncodeScaleWaterAcc[] =$/;"	v
FALSE	Constant.h	18;"	d
FASTA	mypro.h	48;"	d
FFT	myfunc.cpp	/^void FFT(Complex *cplx, int dim, int pow2, bool isInv)\/*{{{*\/$/;"	f
FILE_LABEL	mypro.h	60;"	d
FILE_PRED	mypro.h	59;"	d
FIRST	mypro.h	120;"	d
FilterSSBondPred	mypro.cpp	/^void FilterSSBondPred(const char* gistPredictFile_ss, const char* gistPredictFile_zn, const char* gistPredictFile_zn_2, int numSite_ss, int numSite_zn, double cutoff_discriminant_ss)\/*{{{*\/$/;"	f
FindSCOP	mypro.cpp	/^int FindSCOP(char* pdbid, char chainID, int seqF, int seqT, SCOP* pSCOP, FILE *fpSCOPspi, FILE *fpSCOPspd, char** pdbIDs, long* offsetspi, int numPDB) \/*{{{*\/ $/;"	f
FindSCOP_scopid	mypro.cpp	/^int FindSCOP_scopid(char* scopid, SCOP* pSCOP, FILE *fpSCOPspi, FILE *fpSCOPspd, char** pdbIDs, long* offsetspi, int numPDB) \/*{{{*\/ $/;"	f
FragCanInt5	mypro.h	/^struct FragCanInt5\/*{{{*\/$/;"	s
FragCanInt6	mypro.h	/^struct FragCanInt6\/*{{{*\/$/;"	s
FragCanShort5	mypro.h	/^struct FragCanShort5\/*{{{*\/$/;"	s
FragCanShort6	mypro.h	/^struct FragCanShort6\/*{{{*\/$/;"	s
GAP	mypro.h	105;"	d
GAP_CHAR	mypro.cpp	/^char GAP_CHAR = CHAR_INDEL;$/;"	v
GAP_DIGIT	mypro.cpp	/^int GAP_DIGIT = DIGIT_INDEL;$/;"	v
GCG	mypro.h	47;"	d
GatingScore	myfunc.cpp	/^double GatingScore(double x, double y)\/*{{{*\/$/;"	f
GetAASeqIndex	mypro.cpp	/^int GetAASeqIndex(const char* id, int resSeq, char resICode, Chain* pChain, int startIndex \/*= 0*\/)\/*{{{*\/$/;"	f
GetAllSubset	mypro.cpp	/^int GetAllSubset(int **subset, int n, int k)\/*{{{*\/$/;"	f
GetAltAtomIndex	mypro.cpp	/^int GetAltAtomIndex(Atom *atoms, int n)\/*{{{*\/$/;"	f
GetAmpPha	myfunc.cpp	/^void GetAmpPha(double re, double im, double& amp, double& pha)\/*{{{*\/$/;"	f
GetAtom_PDB	mypro.cpp	/^int GetAtom_PDB(const char *pdbfile, Atom *atom, int *pNumAtom, bool isGetAllChain \/*= true*\/, int max_num_atom \/*= MAX_ATOM_SERIAL*\/, char* chainIDList \/*= ""*\/, bool isRestrictByContactAtom \/* = true*\/, Atom *metalAtom \/*= NULL*\/, int *pNumMetalAtom \/*= NULL*\/, int max_num_metal_atom \/* = MAX_METAL_CHAIN*\/)\/*{{{*\/$/;"	f
GetBinaryFragInt5	mypro.cpp	/^int GetBinaryFragInt5(const char *file, int &fragFileType, char **idList, int &numID, int &maxSizeID, int &length, short *posTar, short *numCan, int &totalFragCan, FragCanInt5 *fragCan)\/*{{{*\/$/;"	f
GetBinaryFragInt6	mypro.cpp	/^int GetBinaryFragInt6(const char *file, int &fragFileType, char **idList, int &numID, int &maxSizeID, int &length, short *posTar, short *numCan, int &totalFragCan, FragCanInt6 *fragCan)\/*{{{*\/$/;"	f
GetBinaryFragShort5	mypro.cpp	/^int GetBinaryFragShort5(const char *file, int &fragFileType, char **idList, int &numID, int &maxSizeID, int &length, short *posTar, short *numCan, int &totalFragCan, FragCanShort5 *fragCan)\/*{{{*\/$/;"	f
GetBinaryFragShort6	mypro.cpp	/^int GetBinaryFragShort6(const char *file, int &fragFileType, char **idList, int &numID, int &maxSizeID, int &length, short *posTar, short *numCan, int &totalFragCan, FragCanShort6 *fragCan)\/*{{{*\/$/;"	f
GetBinaryMODM	mypro.cpp	/^template <class T> int GetBinaryMODM(const char *file, char *alphabet, int &length, T *profile, double *parameter, int8 &typeProfile)\/*{{{*\/$/;"	f
GetBinaryMODMPara	mypro.cpp	/^int8 GetBinaryMODMPara(const char *file, int &sizeAlphabet, int &length, int8 &typeProfile)\/*{{{*\/$/;"	f
GetBkFreq	mypro.cpp	/^int GetBkFreq(const char *infile, double *P, const char *alphabet, int num_aa \/*= NUM_AA*\/)\/*{{{*\/$/;"	f
GetColSize	array.h	/^	unsigned int GetColSize(void)    {return this->colSize; }$/;"	f	class:Array2D_Sub
GetColSize	array.h	/^template <class T>  unsigned int Array2D<T>::GetColSize(void) { return  colSize;} $/;"	f	class:Array2D
GetContactDist	mypro.cpp	/^double GetContactDist(const char* eleName)\/*{{{*\/$/;"	f
GetDSSPChain	mypro.cpp	/^int GetDSSPChain(const char* id, Chain* pChain, const char* dsspfilepath)\/*{{{*\/$/;"	f
GetDSSPFilePath	myfunc.cpp	/^char* GetDSSPFilePath(const char* pdbid, char* dsspfilepath, const char dssppath[] \/*= ""*\/)\/*{{{*\/$/;"	f
GetDataDir	myfunc.cpp	/^int GetDataDir(char *datadir)\/*{{{*\/$/;"	f
GetDimensionVectorPerSite	mypro.cpp	/^int GetDimensionVectorPerSite(int P, bool isCenterResidue)\/*{{{*\/$/;"	f
GetEncodeDistance	mypro.cpp	/^int GetEncodeDistance(int dist)\/*{{{*\/$/;"	f
GetEncodeHydrophobicity	mypro.cpp	/^int GetEncodeHydrophobicity(double hydrophobicity)\/*{{{*\/$/;"	f
GetEncodeScore1	mypro.cpp	/^int GetEncodeScore1(double score1)\/*{{{*\/$/;"	f
GetEncodeScore2	mypro.cpp	/^int GetEncodeScore2(double score2)\/*{{{*\/$/;"	f
GetEncodeWaterAcc	mypro.cpp	/^int GetEncodeWaterAcc(int waterAcc)\/*{{{*\/$/;"	f
GetGistPredResidue	mypro.cpp	/^int GetGistPredResidue(FILE* fpGistPred, int numSite, GistPredChain *pChain, int operation)\/*{{{*\/$/;"	f
GetGistPredResidue	mypro.cpp	/^int GetGistPredResidue(const char* gistPredFile, int numSite, GistPredChain *chains, int operation)\/*{{{*\/$/;"	f
GetHCRes	mypro.cpp	/^int GetHCRes(MODM *pMODM, bool *isPolyHis, Residue* HCRes, double cutoff_score2, double cutoff_consv, char* resList, bool isUseConsvI, bool isMaskPolyHis)\/*{{{*\/$/;"	f
GetIntegConsv	mypro.cpp	/^template <class T> T GetIntegConsv(char aa, T *V, char* alphabetMODM, int type_modm \/*= MODM_PER*\/)\/*{{{*\/$/;"	f
GetLongestGaplessMatch	createseqmap.cpp	/^int GetLongestGaplessMatch (int *alignRel, int alignLength) \/*2010-01-15*\/\/*{{{*\/$/;"	f
GetMODM	mypro.cpp	/^template <class T> int GetMODM(const char* modmfilepath, T ** M \/*= NULL*\/, char* alphabetMODM \/*= NULL*\/, char* aaSeq \/*= NULL*\/,double* score1 \/*= NULL*\/,double* score2 \/*= NULL*\/, double *parameter \/*=NULL*\/, int *seqIndex\/*=NULL*\/, int startIndex\/*=1*\/)\/*{{{*\/$/;"	f
GetMODMFilePath	myfunc.cpp	/^char* GetMODMFilePath(const char* id, char* modmfilepath, const char modmpath[] \/*= ""*\/ )\/*{{{*\/$/;"	f
GetMetalBoundRes	mypro.cpp	/^int GetMetalBoundRes(const char* metalProFile, MetalPro* metalPro, int &numMetalPro, bool isExcludeOtherChainRes\/* = true*\/, char **keyMetalList\/* = NULL*\/, int numKeyMetal\/* = 0*\/, int min_metalBoundRes \/*= 0 *\/, int max_metalBoundRes \/*= 0*\/, bool isUsingTotalBoundRes \/* = true*\/)\/*{{{*\/$/;"	f
GetMetalBoundRes2	mypro.cpp	/^int GetMetalBoundRes2(const char* metalProFile, MetalPro* metalPro1, MetalPro* metalPro2, int &numMetalPro1, int &numMetalPro2, int &numMetalRes1, int &numMetalRes2, char *resList, const char* modmpath, bool isExcludeOtherChainRes\/* = true*\/, char **keyMetalList\/* = NULL*\/, int numKeyMetal\/* = 0*\/, int min_metalBoundRes \/*= 0 *\/, int max_metalBoundRes \/*= 0*\/, bool isUsingTotalBoundRes \/* = true*\/)\/*{{{*\/$/;"	f
GetMetalBoundRes3	mypro.cpp	/^int GetMetalBoundRes3(const char* metalProFile, MetalPro* metalPro, MetalPro* metalPro1, MetalPro* metalPro2, int &numMetalPro, int &numMetalPro1, int &numMetalPro2, int &numMetalRes, int &numMetalRes1, int &numMetalRes2, double cutoff_score2, char *resList, const char* modmpath, bool isExcludeOtherChainRes\/* = true*\/, char **keyMetalList\/* = NULL*\/, int numKeyMetal\/* = 0*\/, int min_metalBoundRes \/*= 0 *\/, int max_metalBoundRes \/*= 0*\/, bool isUsingTotalBoundRes \/* = true*\/)\/*{{{*\/$/;"	f
GetMetalElementList	mypro.cpp	/^int GetMetalElementList(Element *metalEle, const char metalElementListFile[] \/*= ""*\/ \/*"\/data\/metal_element_list.dat"*\/ )\/*{{{*\/$/;"	f
GetNextResidue_PDB	mypro.cpp	/^int GetNextResidue_PDB(Residue *pRes, FILE *fpPDBFile, bool isGetAllAtomLocation  \/*=false*\/)\/*{{{*\/$/;"	f
GetNumBoundRes	mypro.cpp	/^int GetNumBoundRes(set<int> const& PrP, set<int> const& PrN, MetalPro* pZnPro, set <int> &TP, set <int> &FP, set<int> &TN, set<int> &FN) \/*{{{*\/$/;"	f
GetNumBoundRes	mypro.cpp	/^int GetNumBoundRes(set<int> const& idx, MetalPro* pZnPro, set <int> &idxTrue, set <int> &idxFalse) \/*{{{*\/$/;"	f
GetNumBoundRes	mypro.cpp	/^int GetNumBoundRes(set<int> const& idx, MetalPro2* pZnPro, set <int> &idxTrue, set<int> &idxFalse) \/*{{{*\/$/;"	f
GetNumBoundRes	mypro.cpp	/^int GetNumBoundRes(set<int> const& idx, SSBondPro* pPro, set <int> &idxTrue, set <int> &idxFalse) \/*{{{*\/$/;"	f
GetNumDigit	myfunc.cpp	/^int GetNumDigit(int num)\/*{{{*\/$/;"	f
GetPDBAAFilePath	myfunc.cpp	/^char* GetPDBAAFilePath(const char* id, char* pdbaafilepath, const char pdbaapath[] \/*= ""*\/)\/*{{{*\/$/;"	f
GetPDBChainIDList	createseqmap.cpp	/^int GetPDBChainIDList(const char* pdbfile, char *chainIDList)\/*{{{*\/$/;"	f
GetPDBFilePath	myfunc.cpp	/^char* GetPDBFilePath(const char* pdbid, char* pdbfilepath, const char pdbpath[] \/*=""*\/, const char pdbobsoletepath[] \/*=""*\/, const char pdbmodelspath[] \/*=""*\/, const char pdbmodelsobsoletepath[]\/*=""*\/)\/*{{{*\/$/;"	f
GetPSSM	mypro.cpp	/^int GetPSSM(const char *infile, int &length, char *aaSeq \/*=NULL*\/, int **Mij\/*=NULL*\/, int **fij\/*=NULL*\/, double *score1\/*=NULL*\/, double *score2\/*=NULL*\/, double *parameter\/*=NULL*\/, int *seqIndex\/*=NULL*\/)\/*{{{*\/$/;"	f
GetPSSMFilePath	myfunc.cpp	/^char* GetPSSMFilePath(const char* id, char* pssmfilepath, const char pssmpath[] \/*= ""*\/)\/*{{{*\/$/;"	f
GetParameter	shapestring.cpp	/^int GetParameter(const char *shapestring_rawdata_path, int8*** Shapestring, int *Align_Table, bool isReadTextRawdata = false)\/*{{{*\/$/;"	f
GetPatternTransMatrix	mypro.h	245;"	d
GetResidueIndex	mypro.cpp	/^int GetResidueIndex(Atom *pAtom, Residue *resGroup, int numRes)\/*{{{*\/$/;"	f
GetResidueIndex	mypro.cpp	/^int GetResidueIndex(Residue *pRes, Residue *resGroup, int numRes)\/*{{{*\/$/;"	f
GetRowSize	array.h	/^	unsigned int GetRowSize(void)	{return this->rowSize; }$/;"	f	class:Array2D_Sub
GetRowSize	array.h	/^template <class T>  unsigned int Array2D<T>::GetRowSize(void) { return  rowSize;} $/;"	f	class:Array2D
GetSCOPAAFilePath	myfunc.cpp	/^char* GetSCOPAAFilePath(const char* id, char* scopaafilepath, const char scopaapath[] \/*= ""*\/)\/*{{{*\/$/;"	f
GetSEQMAP	mypro.cpp	/^int GetSEQMAP(const char* seqmapfilepath, Chain *pChain)\/*{{{*\/$/;"	f
GetSEQMAPFilePath	myfunc.cpp	/^char* GetSEQMAPFilePath(const char* id, char* seqmapfilepath, const char seqmappath[] \/*= ""*\/)\/*{{{*\/$/;"	f
GetSEQRESSeq	getseqresseq.cpp	/^int GetSEQRESSeq(const char* pdbfile, Chain *chains, char *chainIDList, int &numChain)\/*{{{*\/$/;"	f
GetSSBondRes	mypro.cpp	/^int GetSSBondRes(const char* ssbondProFile, SSBondPro *ssbondPro, int &numSSBondPro, int &numSSBondRes)\/*{{{*\/$/;"	f
GetSSBondRes2	mypro.cpp	/^int GetSSBondRes2(const char *ssbondProFile, SSBondPro *ssbondPro, SSBondPro *ssbondPro1,int &numSSBondPro, int &numSSBondPro1, int &numSSBondRes, int &numSSBondRes1, double cutoff_score2, const char* modmpath)\/*{{{*\/$/;"	f
GetSVMVector	mypro.cpp	/^int GetSVMVector(int *aaSeqIndex, int numSite, MODM *pMODM, int K, int W, int P, double *vector, int vectorDim, double cutoff_score2 \/*= 0.1*\/, int encoding_type \/*= PSSM_PROFILE_ENCODE*\/)\/*{{{*\/$/;"	f
GetSVMVector	mypro.cpp	/^int GetSVMVector(int aaSeqIndex, MODM *pMODM, int K, int P,double* vector, double cutoff_score2 \/*= 0.1*\/)\/*{{{*\/$/;"	f
GetSVMVector	mypro.cpp	/^int GetSVMVector(int aaSeqIndex1, int aaSeqIndex2, MODM *pMODM, int K, int W,int P, double *vector, double cutoff_score2 \/*= 0.1*\/)\/*{{{*\/$/;"	f
GetSVMVectorPerSite	mypro.cpp	/^int GetSVMVectorPerSite(double *vector, int vector_beg, int seqPos, int P, MODM *pMODM, double W1, double W2, double W3, double W4, double W5, double cutoff_score2, int encoding_type \/* = PSSM_PROFILE_ENCODE*\/)\/*{{{*\/$/;"	f
GetSVMVectorPerSite_2	mypro.cpp	/^int GetSVMVectorPerSite_2(double *vector, int vector_beg, int seqPos, int P, int dimVectorPerSite, MODM *pMODM, double w1, double w2, double w3, double w4, double w5, double cutoff_score2, bool isCenterResidue, int encoding_type \/* = PSSM_PROFILE_ENCODE*\/)\/*{{{*\/$/;"	f
GetSVMVector_2	mypro.cpp	/^int GetSVMVector_2(int *aaSeqIndex, int numSite, MODM *pMODM, int K, int W, int P, double *vector, int vectorDim, double cutoff_score2 \/*= 0.1*\/, int encoding_type \/*= PSSM_PROFILE_ENCODE*\/)\/*{{{*\/$/;"	f
GetScore_PPAlignment	mypro.cpp	/^template <class T> double GetScore_PPAlignment(T *va, T* vb, T *log_va, T* log_vb, int formula \/*= 0 *\/, const double *P \/*=NULL*\/, const double *log_P \/*= NULL *\/)\/*{{{*\/$/;"	f
GetSelectedSEQRESSeq	getseqresseq.cpp	/^int GetSelectedSEQRESSeq(const char *pdbfile, const char* chainids, FILE *fpout, int idtype = 0, int lineLength = 70)\/*{{{*\/$/;"	f
GetSeq_ATOM	mypro.cpp	/^int GetSeq_ATOM(const char* pdbfile, Chain *chain, char* chainIDList,  bool isGetAllChain \/*= false*\/,bool isIncludeHETATM \/*= true*\/, int max_seq_length \/* = LONGEST_SEQ*\/, FILE *fpLog \/*= stdout*\/)\/*{{{*\/$/;"	f
GetSeq_ATOM	mypro.cpp	/^int GetSeq_ATOM(const char* pdbfilepath, const char *id, char *aaSeq, int *resSer, char *resICode, FILE *fpLog \/*= stdout*\/)\/*{{{*\/$/;"	f
GetSeq_SEQRES	createseqmap.cpp	/^int GetSeq_SEQRES(const char* pdbfile, Chain *chains, char *chainIDList, int &numChain)\/*{{{*\/$/;"	f
GetSeq_SEQRES	shapestring.cpp	/^int GetSeq_SEQRES(const char* pdbfile, char chainID, char *seq)\/*{{{*\/$/;"	f
GetShapeString	shapestring.cpp	/^int GetShapeString(const char *pdbfile, char* chainIDList, char *title, int *Align_Table, int8 *** Shapestring, bool isPrintAASeq, const char* aaSeqFile, const char* dsspFile, FILE *fpout, FILE *fpAlign)\/*{{{*\/$/;"	f
GetShapeStringFilePath	myfunc.cpp	/^char* GetShapeStringFilePath(const char* id, char* shapestringfilepath, const char shapestringpath[] \/*= ""*\/)\/*{{{*\/$/;"	f
GetSize	array.h	/^template <class T> unsigned int Array1D<T>::GetSize(void)  { return  size;} $/;"	f	class:Array1D
GetTMPDir	myfunc.cpp	/^int GetTMPDir(char *tmpdir)\/*{{{*\/$/;"	f
GetTupingQij	mypro.cpp	/^int GetTupingQij(const char *infile, int **M, char *aaSeq, char *shapeSeq, char *dsspSeq, int *waterAcc, double *score1, double *score2, int *seqIndex, int startIndex\/*=1*\/, const int *mapIndex\/*=MAPINDEX_BLOSUM_Tuping*\/)\/*{{{*\/$/;"	f
GetWorkDir	myfunc.cpp	/^int GetWorkDir(char *workdir)\/*{{{*\/$/;"	f
GetXSize	array.h	/^template <class T>  unsigned int Array3D<T>::GetXSize(void) { return  xSize;} $/;"	f	class:Array3D
GetYSize	array.h	/^template <class T>  unsigned int Array3D<T>::GetYSize(void) { return  ySize;} $/;"	f	class:Array3D
GetZSize	array.h	/^template <class T>  unsigned int Array3D<T>::GetZSize(void) { return  zSize;} $/;"	f	class:Array3D
GetZnBoundRes	mypro.cpp	/^int GetZnBoundRes(const char* metalProFile, MetalPro* znPro, int min_numRes \/*= 3*\/ , int max_numRes \/*= 4*\/, bool isUsingTotalBoundRes \/*= true*\/)\/*{{{*\/$/;"	f
GetZnBoundRes	mypro.cpp	/^int GetZnBoundRes(const char* metalProFile, MetalPro2* znPro, int min_numRes \/*= 3*\/, int max_numRes \/*= 4*\/, bool isUsingTotalBoundRes \/* = true*\/)\/*{{{*\/$/;"	f
GetZnBoundRes3	mypro.cpp	/^int GetZnBoundRes3(const char* metalProFile, MetalPro* znPro, MetalPro* znPro1, MetalPro* znPro2, int &numZnPro, int &numZnPro1, int &numZnPro2, int &numZnRes, int &numZnRes1, int &numZnRes2, double cutoff_score2, char *resList, const char* modmpath, int min_ZnBoundRes \/*= 3*\/, int max_ZnBoundRes \/*= 4*\/, bool isUsingTotalBoundRes \/*= true*\/)\/*{{{*\/$/;"	f
GetZnBoundRes3	mypro.cpp	/^int GetZnBoundRes3(const char* metalProFile, MetalPro2* znPro, MetalPro2* znPro1, MetalPro2* znPro2, int &numZnPro, int &numZnPro1, int &numZnPro2,int &numZnRes, int &numZnRes1, int &numZnRes2, double cutoff_score2, char *resList, const char* modmpath, int min_ZnBoundRes \/*= 3*\/, int max_ZnBoundRes \/*= 4*\/, bool                    isUsingTotalBoundRes \/*= true*\/)\/*{{{*\/$/;"	f
GistPredChain	mypro.h	/^struct GistPredChain\/*{{{*\/$/;"	s
Grouping	myfunc.cpp	/^int Grouping(char **strs, int numStrs, char **strGroup, int *subTotal,int SIZE_STRGROUP)\/*{{{*\/$/;"	f
HAS_ARRAY_H	array.h	17;"	d
HAS_CONSTANT_H	Constant.h	14;"	d
HAS_DATATYPE_H	DataType.h	17;"	d
HAS_MYFUNC_H	myfunc.h	2;"	d
HAS_MYPRO_H	mypro.h	2;"	d
HAS_MYTEMPLATE_H	mytemplate.h	20;"	d
HCRes_window	mypro.cpp	/^int HCRes_window(Residue* HCRes, int& numRes, int sizeGroup, int cutoff_window)\/*{{{*\/$/;"	f
HORIZONTAL	mypro.h	89;"	d
Hydrophobicity	mypro.cpp	/^const double Hydrophobicity[] = { \/*{{{*\/$/;"	v
IDT	mypro.h	102;"	d
INIT_AASEQINDEX	myfunc.h	56;"	d
INIT_CONSV	myfunc.h	48;"	d
INIT_DOUBLE	Constant.h	73;"	d
INIT_FLOAT	Constant.h	72;"	d
INIT_ICODE	myfunc.h	60;"	d
INIT_INT	Constant.h	71;"	d
INIT_RESSEQ	myfunc.h	52;"	d
INIT_SHAPE	myfunc.h	64;"	d
INIT_WATERACC	myfunc.h	68;"	d
INTER	mypro.h	122;"	d
IS_EQUAL	myfunc.h	89;"	d
Init	array.h	/^template <class T>  void Array2D<T>::Init(T initValue) \/*{{{*\/$/;"	f	class:Array2D
Init	array.h	/^template <class T>  void Array3D<T>::Init(T initValue) \/*{{{*\/$/;"	f	class:Array3D
Init	array.h	/^template <class T> void Array1D<T>::Init(T initValue) \/*{{{*\/$/;"	f	class:Array1D
InitAlignFactor	mypro.cpp	/^void InitAlignFactor(AlignFactor *pAlignFactor)\/*{{{*\/$/;"	f
InitAtom	mypro.cpp	/^void InitAtom(Atom * pAtom)\/*{{{*\/$/;"	f
InitAtomEnv	mypro.cpp	/^void InitAtomEnv(AtomEnv *pAtomEnv)\/*{{{*\/$/;"	f
InitAtomFreq	mypro.cpp	/^void InitAtomFreq(AtomFreq *pAtomFreq)\/*{{{*\/$/;"	f
InitChain	mypro.cpp	/^void InitChain(Chain * pChain)\/*{{{*\/$/;"	f
InitDSSPRes	mypro.cpp	/^void InitDSSPRes(DSSP_Residue* dssp_res)\/*{{{*\/$/;"	f
InitDomainDEF	mypro.cpp	/^void InitDomainDEF(DomainDEF *pDomainDEF)\/*{{{*\/$/;"	f
InitGistPredChain	mypro.cpp	/^void InitGistPredChain(GistPredChain * pChain)\/*{{{*\/$/;"	f
InitMODM	mypro.cpp	/^void InitMODM(MODM *pMODM)\/*{{{*\/$/;"	f
InitMSA	mypro.cpp	/^void InitMSA(MSA *pMSA)\/*{{{*\/$/;"	f
InitMetalPro	mypro.cpp	/^void InitMetalPro(MetalPro *pMetalPro )\/*{{{*\/$/;"	f
InitMetalPro	mypro.cpp	/^void InitMetalPro(MetalPro2 *pMetalPro)\/*{{{*\/$/;"	f
InitPredPro	mypro.cpp	/^void InitPredPro(PredPro *pPredPro)\/*{{{*\/$/;"	f
InitResidue	mypro.cpp	/^void InitResidue(Residue *pRes)\/*{{{*\/$/;"	f
InitSCOP	mypro.cpp	/^void InitSCOP(SCOP *pSCOP)\/*{{{*\/$/;"	f
InitSSBond	mypro.cpp	/^void InitSSBond(SSBond *pSSBond )\/*{{{*\/$/;"	f
InitSSBondPro	mypro.cpp	/^void InitSSBondPro(SSBondPro *pSSBondPro )\/*{{{*\/$/;"	f
Integer	myfunc.cpp	/^int Integer(double x)\/*{{{*\/$/;"	f
Is0Chain	mypro.h	247;"	d
IsBlankLine	myfunc.cpp	/^bool IsBlankLine(const char *buf)\/*{{{*\/$/;"	f
IsDNASeq	mypro.cpp	/^bool IsDNASeq(const char *aaSeq, int n \/*= 0*\/)\/*{{{*\/$/;"	f
IsDigit	myfunc.cpp	/^bool IsDigit(const char ch)\/*{{{*\/$/;"	f
IsDigit	myfunc.cpp	/^bool IsDigit(const char* str)\/*{{{*\/$/;"	f
IsHEMPro	mypro.cpp	/^bool IsHEMPro(MODM *pMODM, bool *isPolyHis)\/*{{{*\/$/;"	f
IsInCharSet	myfunc.cpp	/^bool IsInCharSet(const char ch, const char *charSet, int n \/*= 0 *\/)\/*{{{*\/$/;"	f
IsInContactAtomList	mypro.cpp	/^bool IsInContactAtomList(const char *atomOrigName)\/*{{{*\/$/;"	f
IsInteger	myfunc.cpp	/^bool IsInteger(double x)\/*{{{*\/$/;"	f
IsLower	myfunc.cpp	/^bool IsLower(const char c)\/*{{{*\/$/;"	f
IsMetalAtom	mypro.cpp	/^bool IsMetalAtom(Atom *pAtom, char **metalEleList, int numMetalEle)\/*{{{*\/$/;"	f
IsNewResidue	mypro.cpp	/^bool IsNewResidue(Atom *pAtom, Residue *resGroup, int numRes)\/*{{{*\/$/;"	f
IsNewResidue	mypro.cpp	/^bool IsNewResidue(Residue *pRes, Residue *resGroup, int numRes)\/*{{{*\/$/;"	f
IsNonMetalHetGroup	mypro.cpp	/^bool IsNonMetalHetGroup(const char *resName)\/*{{{*\/$/;"	f
IsNumeric	myfunc.cpp	/^bool IsNumeric(const char* str)\/*{{{*\/$/;"	f
IsSSBonded	mypro.cpp	/^bool IsSSBonded(int aaSeqIndex, SSBondPro *ssbondPro)\/*{{{*\/$/;"	f
IsSatisfyHCResRule	mypro.cpp	/^bool IsSatisfyHCResRule(char* id, MODM *pMODM,  bool *isPolyHis,  \/*{{{*\/ $/;"	f
IsSatisfySHCRRule	mypro.cpp	/^bool IsSatisfySHCRRule(int *HCResAASeqIndex, int numRes, int min_numHCRes, int cutoff_window_pair, int cutoff_window_zn3, int cutoff_window_zn4, int* shcr_res_idx, int &numSHCRRes)\/*{{{*\/$/;"	f
IsSpecChain	mypro.cpp	/^int  IsSpecChain(const char* id, const char chainid \/* = '0'*\/)\/*{{{*\/$/;"	f
IsUpper	myfunc.cpp	/^bool IsUpper(const char c)\/*{{{*\/$/;"	f
IsZero	myfunc.cpp	/^bool IsZero(Complex *cplx, int dim)\/*{{{*\/$/;"	f
IsZnBound	mypro.cpp	/^bool IsZnBound(int aaSeqIndex, MetalPro *znPro)\/*{{{*\/$/;"	f
IsZnBound	mypro.cpp	/^bool IsZnBound(int aaSeqIndex1, int aaSeqIndex2, MetalPro *znPro, bool operation)\/*{{{*\/$/;"	f
IsZnBound	mypro.cpp	/^bool IsZnBound(int aaSeqIndex1, int aaSeqIndex2, MetalPro2 *znPro, bool operation)\/*{{{*\/$/;"	f
LAST	mypro.h	121;"	d
LEFT	mypro.h	98;"	d
LOCAL_INIT_SHAPE	createseqmap.cpp	35;"	d	file:
LONGEST_SEQ	Constant.h	171;"	d
LONGEST_SHAPE	Constant.h	172;"	d
LinearSearch_String	myfunc.cpp	/^template <class T> int LinearSearch_String(T keyStr, T* strs, int n) \/*{{{*\/$/;"	f
Ln_Background_AA_Freq	mypro.cpp	/^const double Ln_Background_AA_Freq[] = { -2.551, -2.976, -3.101, -2.919, -3.963, -3.147, -2.765, -2.604, -3.817, -2.957, -2.408, -2.865, -3.817, -3.244, -2.957, -2.645, -2.830, -4.343, -3.442, -2.749 };\/\/ln of Background_AA_Freq, ordered by BLOSUM1D_alphabet$/;"	v
M	mypro.h	/^    DATATYPE_MODM_MATRIX    **M;     \/\/the pssm matrix$/;"	m	struct:MODM
MAPINDEX_BLOSUM_Tuping	mypro.cpp	/^const int MAPINDEX_BLOSUM_Tuping[] = {0, 19, 10, 9, 14, 13, 12, 11, 1, 8, 7, 15, 16, 4, 18, 2, 6, 17, 3, 5 };\/\/index that map AAAlphabet_Tuping to BLOSUM1D_alphabet$/;"	v
MAXSeqLen	shapestring.cpp	/^int MAXSeqLen = 20000;$/;"	v
MAX_ALTATOM	Constant.h	165;"	d
MAX_ATOMENV	mypro.cpp	/^    int MAX_ATOMENV      = 50;$/;"	v
MAX_ATOMENV	mypro.cpp	/^    int MAX_ATOMENV   = 30;$/;"	v
MAX_ATOM_PER_RES	Constant.h	163;"	d
MAX_ATOM_PER_RES_WITH_ALTATOM	Constant.h	164;"	d
MAX_ATOM_SERIAL	Constant.h	114;"	d
MAX_BONDED_RES_CHAIN	Constant.h	175;"	d
MAX_BOUND_METAL_PER_RES	mypro.cpp	/^    int MAX_BOUND_METAL_PER_RES = 10; \/\/ maximal number of metal atoms bound to a residue$/;"	v
MAX_BOUND_METAL_PER_RES	mypro.cpp	/^    int MAX_BOUND_METAL_PER_RES = 10; \/\/ maximal number of metal atoms bound to a residue, set to a large value, e.g 1AOO, Cys9 bind to 4 Ag(I) atoms, if set the cutoff_distance to a larger value, then, this value can be more than 5$/;"	v
MAX_BOUND_SITE	mypro.cpp	/^    int MAX_BOUND_SITE    = 10;   \/\/ maximal number of coordinate bound$/;"	v
MAX_BOUND_SITE	mypro.cpp	/^    int MAX_BOUND_SITE = 10;   \/\/ maximal number of coordinate bound$/;"	v
MAX_CLOSE_RESIDUE	Constant.h	177;"	d
MAX_COMMAND_LINE	Constant.h	34;"	d
MAX_DOUBLE	Constant.h	67;"	d
MAX_FLOAT	Constant.h	64;"	d
MAX_INT	Constant.h	61;"	d
MAX_METAL_CHAIN	Constant.h	176;"	d
MAX_NRPDB_LIST	Constant.h	169;"	d
MAX_NUMRES	mypro.cpp	/^    int MAX_NUMRES       = 200;  \/\/ maximal number of residues bind to zinc atom per chain$/;"	v
MAX_NUMRES	mypro.cpp	/^    int MAX_NUMRES    = 30;  \/\/ maximal number of residues bind to zinc atom per chain$/;"	v
MAX_NUM_CHAIN	createseqmap.cpp	40;"	d	file:
MAX_NUM_CHAIN	createseqmap.cpp	41;"	d	file:
MAX_NUM_METALPRO	mypro.cpp	/^    int MAX_NUM_METALPRO = 1500;$/;"	v
MAX_NUM_NRPDB	Constant.h	168;"	d
MAX_NUM_PDB	Constant.h	167;"	d
MAX_NUM_PDBID	getpdbfilepath.cpp	7;"	d	file:
MAX_NUM_PDBID	getpdbfilepath.cpp	8;"	d	file:
MAX_NUM_ZNPRO	mypro.cpp	/^    int MAX_NUM_ZNPRO = 400;$/;"	v
MAX_PATH	Constant.h	30;"	d
MAX_PATH	getdsspfilepath.cpp	9;"	d	file:
MAX_SEQ_LENGTH	Constant.h	173;"	d
MAX_SIZE_ID	createseqmap.cpp	37;"	d	file:
MAX_SIZE_ID	createseqmap.cpp	38;"	d	file:
MAX_SSBOND_CHAIN	Constant.h	159;"	d
MAX_SSBOND_PRO	Constant.h	160;"	d
MIN_DOUBLE	Constant.h	68;"	d
MIN_FLOAT	Constant.h	65;"	d
MIN_INT	Constant.h	62;"	d
MIN_MATCH_LENGTH	createseqmap.cpp	/^int MIN_MATCH_LENGTH = 3;$/;"	v
MIS	mypro.h	104;"	d
MODM	mypro.h	/^struct MODM\/*{{{*\/$/;"	s
MODM_FILE_TYPE	myfunc.h	42;"	d
MODM_FILE_TYPE	mypro.h	32;"	d
MODM_LOG	myfunc.h	43;"	d
MODM_LOG	mypro.h	33;"	d
MODM_PER	myfunc.h	44;"	d
MODM_PER	mypro.h	34;"	d
MSA	mypro.h	/^struct MSA\/*{{{*\/  \/*data structure for multiple sequence alignment*\/$/;"	s
MSA_FORMAT	mypro.h	44;"	d
MSF	mypro.h	46;"	d
MaskPolyHis	mypro.cpp	/^int MaskPolyHis(const char *aaSeq, bool *isPolyHis, int length \/*= 0*\/)\/*{{{*\/$/;"	f
MergeGistResidue	mypro.cpp	/^void MergeGistResidue(GistPredChain *pChain, int *idx, int start, int end,  int &label, double &discriminant, int operation)\/*{{{*\/$/;"	f
MetalBindPro	mypro.h	/^struct MetalBindPro\/*{{{*\/$/;"	s
MetalBindingProtein	mypro.cpp	/^namespace MetalBindingProtein$/;"	n	file:
MetalBindingProtein	mypro.h	/^namespace MetalBindingProtein$/;"	n
MetalPro	mypro.h	/^struct MetalPro\/*{{{*\/$/;"	s
MetalPro2	mypro.h	/^struct MetalPro2 \/\/  in MetalPro2, residues are stored according to metal atom\/*{{{*\/$/;"	s
NN	getdsspfilepath.cpp	12;"	d	file:
NN	getdsspfilepath.cpp	13;"	d	file:
NN	getpdbaafilepath.cpp	31;"	d	file:
NULL	Constant.h	26;"	d
NULLCHAR	Constant.h	43;"	d
NULL_ICODE	mypro.h	133;"	d
NUM_20_AA	mypro.h	135;"	d
NUM_AA	mypro.h	69;"	d
NUM_BLOSUM	mypro.h	70;"	d
NUM_CHAINS	mypro.h	80;"	d
NUM_CHAIN_PER_DOMAIN	Constant.h	98;"	d
NUM_DNA	mypro.h	68;"	d
NUM_DOMAIN_PDB	Constant.h	99;"	d
NUM_METAL_ELEMENT	Constant.h	162;"	d
NUM_NUC	mypro.h	73;"	d
NUM_SHAPE	mypro.h	77;"	d
NUM_SHAPES	mypro.cpp	410;"	d	file:
NUM_SHAPES	mypro.h	156;"	d
NUM_STDAA	mypro.h	136;"	d
OR	mypro.h	117;"	d
PDB1CharAA_alphabet	mypro.cpp	/^const char PDB1CharAA_alphabet[] = "XARNDBCXQEZGHXILKMFPXSTWYXV";$/;"	v
PDB1Char_AllRes	mypro.cpp	/^const char PDB1Char_AllRes[] = "CLDLRHERCNARGTRAAATCKlRRRDDNDDNDDBACDDTAEGCLCCCCCCSCEASSLCCGSGSQCCACSCCCCCCSCMCCCCCCCCCFARDCEQAHIVLKADFPSDTWYVCFSCAMWEGEQEZGGEKGHARHHHRFFWPDNSIIKYKLKKWKKKKKKANMQMHSLEKKGGMMFVSHHYLLLGCSCCMYSECDFFFACPAPYSACSSGSSCCCSCSSSSSCKCMCDCYDSTAWTAWKWWWWWYYYYYYYXVCY";$/;"	v
PDB3CharAA_alphabet	mypro.cpp	/^const char *PDB3CharAA_alphabet[] = \/\/recognized amino acid residue code in pdb file, ordered \/*{{{*\/$/;"	v
PDB3Char_AllRes	mypro.cpp	/^const char *PDB3Char_AllRes [] = \/\/ all recognizable 3-letter residues in PDB, ordered alphabetically\/*{{{*\/$/;"	v
PDBFileName2PDBID	createdssp.sh	/^function PDBFileName2PDBID()# $pdbfile#{{{$/;"	f
PHYLIP	mypro.h	49;"	d
PI	Constant.h	79;"	d
POS_ALTLOC	Constant.h	127;"	d
POS_ATOMNAME_BEG	Constant.h	124;"	d
POS_ATOMNAME_END	Constant.h	125;"	d
POS_CHAIN_ID	Constant.h	132;"	d
POS_CHARGE_BEG	Constant.h	154;"	d
POS_CHARGE_END	Constant.h	155;"	d
POS_ELEMENT_BEG	Constant.h	152;"	d
POS_ELEMENT_END	Constant.h	153;"	d
POS_ICODE	Constant.h	137;"	d
POS_OCCUPANCY_BEG	Constant.h	146;"	d
POS_OCCUPANCY_END	Constant.h	147;"	d
POS_RECORD_BEG	Constant.h	118;"	d
POS_RECORD_END	Constant.h	119;"	d
POS_RESNAME_BEG	Constant.h	129;"	d
POS_RESNNAME_END	Constant.h	130;"	d
POS_RESSEQ_BEG	Constant.h	134;"	d
POS_RESSEQ_END	Constant.h	135;"	d
POS_SEGID_BEG	Constant.h	150;"	d
POS_SEGID_END	Constant.h	151;"	d
POS_SERIAL_BEG	Constant.h	121;"	d
POS_SERIAL_END	Constant.h	122;"	d
POS_TEMPFACTOR_BEG	Constant.h	148;"	d
POS_TEMPFACTOR_END	Constant.h	149;"	d
POS_X_COOR_BEG	Constant.h	139;"	d
POS_X_COOR_END	Constant.h	140;"	d
POS_Y_COOR_BEG	Constant.h	141;"	d
POS_Y_COOR_END	Constant.h	142;"	d
POS_Z_COOR_BEG	Constant.h	143;"	d
POS_Z_COOR_END	Constant.h	144;"	d
PSSM_PROFILE_ENCODE	mypro.h	39;"	d
PointDef	shapestring.cpp	/^struct PointDef $/;"	s	file:
PredPro	mypro.h	/^struct PredPro\/*{{{*\/$/;"	s
PrintHelp	cShapeStringList.sh	/^function PrintHelp()$/;"	f
PrintHelp	createdssp.sh	/^function PrintHelp()$/;"	f
PrintHelp	createpdbaa.sh	/^function PrintHelp()$/;"	f
PrintHelp	createseqmap.cpp	/^void PrintHelp()$/;"	f
PrintHelp	getdsspfilepath.cpp	/^void PrintHelp()$/;"	f
PrintHelp	getpdbaafilepath.cpp	/^void PrintHelp()$/;"	f
PrintHelp	getpdbfilepath.cpp	/^void PrintHelp()$/;"	f
PrintHelp	getseqresseq.cpp	/^void PrintHelp()$/;"	f
PrintHelp	shapestring.cpp	/^void PrintHelp()$/;"	f
PrintHelp	splitfasta.cpp	/^void PrintHelp()$/;"	f
Profile	mypro.h	/^struct Profile \/*{{{*\/$/;"	s
ProfileByte	mypro.h	/^struct ProfileByte \/*{{{*\/$/;"	s
ProfileSAD	mypro.h	/^struct ProfileSAD\/*{{{*\/$/;"	s
ProfileSADByte	mypro.h	/^struct ProfileSADByte\/*{{{*\/$/;"	s
QuickSort	mytemplate.h	/^template <class T>  void QuickSort(T *sort, int low, int high, int order \/* = ASCENDING*\/)\/*{{{*\/$/;"	f
QuickSort_String	myfunc.cpp	/^void QuickSort_String(int *idx, char** strs, int low, int high)\/*{{{*\/$/;"	f
QuickSort_index	mytemplate.h	/^template <class T>  void QuickSort_index(int *idx, T *sort, int low, int high, int order \/*= ASCENDING*\/)\/*{{{*\/$/;"	f
READ_FILE_ERROR	Constant.h	53;"	d
RESSEQ	mypro.h	83;"	d
ReadInPDBIDs	getpdbfilepath.cpp	/^int ReadInPDBIDs(FILE *fp, char **pdbids, int start_idx)\/*{{{*\/$/;"	f
ReadInProfile	mypro.cpp	/^int ReadInProfile(const char *file, int **M, char *aaSeq \/*= NULL*\/, char *shapeSeq \/*= NULL*\/, int *waterAcc \/*= NULL*\/, char *dsspSec \/*= NULL*\/, float *score1 \/*= NULL*\/, float *score2 \/*= NULL*\/, int *sumProfile \/*= NULL*\/, int maxLength \/*= LONGEST_SEQ*\/)\/*{{{*\/$/;"	f
ReadMSA	mypro.cpp	/^int ReadMSA(const char* msafile, MSA *pMSA, int format \/*= CLUSTALW*\/)\/*{{{*\/$/;"	f
ReadMSA_clustalw	mypro.cpp	/^int ReadMSA_clustalw(const char* msafile, MSA *pMSA)\/*{{{*\/$/;"	f
ReadNextSeq_FASTA	mypro.cpp	/^int ReadNextSeq_FASTA(FILE *fp, char* seq, int *pSeq_type \/*= NULL*\/, int maxlength \/*= LONGEST_SEQ*\/, char* annotationLine\/*=NULL*\/, int maxSizeAnnotationLine \/*=50*\/)\/*{{{*\/$/;"	f
ReadSMatrix	mypro.cpp	/^template <class T> int ReadSMatrix(const char *filename, T **S, char *alphabet)\/*{{{*\/$/;"	f
ReadSeq_FASTA	mypro.cpp	/^int ReadSeq_FASTA(const char *fileName, char* seq, int *pSeq_type \/*= NULL*\/, int maxlength \/*= LONGEST_SEQ*\/, char* annotationLine\/*=NULL*\/, int maxSizeAnnotationLine \/*=50*\/)\/*{{{*\/$/;"	f
RemoveTID	mypro.cpp	/^void RemoveTID(char* id)\/*{{{*\/$/;"	f
Residue	mypro.h	/^struct Residue  \/\/data structure for the residue\/*{{{*\/$/;"	s
RestrictMetalBoundRes	mypro.cpp	/^int RestrictMetalBoundRes(MetalPro *metalPro1, int &numMetalPro1, int &numMetalRes1, MetalPro* metalPro2, int numMetalPro2, char *resList, int level, const char *modmpath \/* = ""*\/, double cutoff_score2 \/* = 0.0*\/)\/*{{{*\/$/;"	f
Row	array.h	/^		Row(Array2D_Sub& _array2D,unsigned int _row):$/;"	f	class:Array2D_Sub::Row
Row	array.h	/^	class Row$/;"	c	class:Array2D_Sub
SCOP	mypro.h	/^struct SCOP\/*{{{*\/$/;"	s
SEQALIGN	mypro.h	94;"	d
SEQUENCE_BINARY_ENCODE	mypro.h	40;"	d
SEQ_TYPE	myfunc.h	72;"	d
SHAPE_SEQ	myfunc.h	75;"	d
SHAPE_alphabet	mypro.cpp	/^const char SHAPE_alphabet[] = "AKSRUVTG-";$/;"	v
SHCR_window	mypro.cpp	/^int SHCR_window(int* HCResAASeqIndex, int numRes, int numSite, int cutoff_window, int cutoff_window_pair, int* shcr_res_idx, int &numSHCRRes)\/*{{{*\/$/;"	f
SIM	mypro.h	103;"	d
SIZE_ATOM_CHARGE	Constant.h	186;"	d
SIZE_ATOM_ELEMENT	Constant.h	185;"	d
SIZE_ATOM_NAME	Constant.h	181;"	d
SIZE_ATOM_ORIGNAME	Constant.h	183;"	d
SIZE_ATOM_SEGID	Constant.h	184;"	d
SIZE_CHAIN_ID	Constant.h	108;"	d
SIZE_DOMAIN_DEF_RECORD	Constant.h	97;"	d
SIZE_ENCODE_AA_CENTER	mypro.cpp	516;"	d	file:
SIZE_ENCODE_AA_CENTER	mypro.h	174;"	d
SIZE_ENCODE_AA_NON_CENTER	mypro.cpp	527;"	d	file:
SIZE_ENCODE_AA_NON_CENTER	mypro.h	178;"	d
SIZE_ENCODE_DISTANCE	mypro.cpp	581;"	d	file:
SIZE_ENCODE_DISTANCE	mypro.h	212;"	d
SIZE_ENCODE_HYDROPHOBICITY	mypro.h	238;"	d
SIZE_ENCODE_PSSM	mypro.h	164;"	d
SIZE_ENCODE_SCORE1	mypro.h	165;"	d
SIZE_ENCODE_SCORE2	mypro.cpp	498;"	d	file:
SIZE_ENCODE_SCORE2	mypro.h	169;"	d
SIZE_ENCODE_WATERACC	mypro.cpp	563;"	d	file:
SIZE_ENCODE_WATERACC	mypro.h	207;"	d
SIZE_ID	splitfasta.cpp	26;"	d	file:
SIZE_ID	splitfasta.cpp	27;"	d	file:
SIZE_LINE_PDB	Constant.h	102;"	d
SIZE_METAL_ATOM_NAME	Constant.h	112;"	d
SIZE_METAL_ATOM_RES_NAME	Constant.h	113;"	d
SIZE_PDBID	Constant.h	103;"	d
SIZE_PDBID	getpdbfilepath.cpp	10;"	d	file:
SIZE_PDBID	getpdbfilepath.cpp	11;"	d	file:
SIZE_RECORD_ID	Constant.h	110;"	d
SIZE_RES_NAME	Constant.h	111;"	d
SIZE_SCOP_ID	Constant.h	96;"	d
SIZE_TITLE	Constant.h	180;"	d
SORT_ORDER	myfunc.h	99;"	d
SSBond	mypro.h	/^struct SSBond\/*{{{*\/$/;"	s
SSBondPro	mypro.h	/^struct SSBondPro\/*{{{*\/$/;"	s
STD1CharAA_alphabet	mypro.cpp	/^const char STD1CharAA_alphabet[] = "ARNDCQEGHILKMFPSTWYVX"; $/;"	v
STD3CharAA_alphabet	mypro.cpp	/^const char *STD3CharAA_alphabet[] = \/*{{{*\/$/;"	v
STOP	mypro.h	96;"	d
ScanfAtomOrigName	mypro.cpp	/^void ScanfAtomOrigName(const char *PDBAtomRecordLine, char * atomOrigName)\/*{{{*\/$/;"	f
ScanfAtomResName	mypro.cpp	/^void ScanfAtomResName(const char *PDBAtomRecordLine, char *atomResName)\/*{{{*\/$/;"	f
ScanfAtomSerial	mypro.cpp	/^void ScanfAtomSerial(const char *PDBAtomRecordLine, int &atomSerial)\/*{{{*\/$/;"	f
ScanfCloseMetalRes	mypro.cpp	/^int ScanfCloseMetalRes(FILE* fpin, Residue* res,int numRes)\/*{{{*\/$/;"	f
ScanfCoorRecord_Atom	mypro.cpp	/^void ScanfCoorRecord_Atom(const char *line, Atom *pAtom)\/*{{{*\/$/;"	f
ScanfCoorRecord_Atom_Simp1	mypro.cpp	/^void ScanfCoorRecord_Atom_Simp1(const char* line, Atom *pAtom)\/*{{{*\/$/;"	f
ScanfDSSPResRecord	mypro.cpp	/^void ScanfDSSPResRecord(const char* line, DSSP_Residue* pDSSPRes)\/*{{{*\/$/;"	f
ScanfGistPredictCard	mypro.cpp	/^int  ScanfGistPredictCard(const char *line, char *id, int &length, int &idx, char *res_1char_list,int *aaSeqIndex, int &label, double &discriminant, int numSite)\/*{{{*\/$/;"	f
ScanfGistVectorLabelCard	mypro.cpp	/^int  ScanfGistVectorLabelCard(const char *line, char *id, int &length, int &idx, char *res_1char_list,int *aaSeqIndex, int &label,  int numSite)\/*{{{*\/$/;"	f
ScanfKernerlRecordID	mypro.cpp	/^int ScanfKernerlRecordID(const char *vectorRecordID, char *id, int &length, int &idx, char *res_1char_list, int *aaSeqIndex, int numSite)\/*{{{*\/$/;"	f
ScanfResRecord3	mypro.cpp	/^void ScanfResRecord3(const char *str, Residue *pRes, int tag)\/*{{{*\/$/;"	f
ScanfSCOPRecord	mypro.cpp	/^void ScanfSCOPRecord(const char *line, SCOP *pSCOP)\/*{{{*\/$/;"	f
ScanfSSBondRecord	mypro.cpp	/^void ScanfSSBondRecord(FILE* fp, SSBondPro* pSSBondPro, int numSSBond)\/*{{{*\/$/;"	f
Scanf_SEQRES_Para	mypro.cpp	/^void Scanf_SEQRES_Para(const char* line,char* title, int& serNum,char& chainID,int& numRes, char* resName)\/*{{{*\/ $/;"	f
Scanf_SEQRES_Record	mypro.cpp	/^int Scanf_SEQRES_Record(const char* line,int resBegin, char* title, int& serNum,char& chainID,int& numRes,char **resName)  \/*{{{*\/$/;"	f
Scanf_SEQRES_Seq	mypro.cpp	/^int Scanf_SEQRES_Seq(const char* line,int resBegin, char **resName)\/*{{{*\/$/;"	f
Select	array.h	/^	T& Select(unsigned int row, unsigned int col)$/;"	f	class:Array2D_Sub
SelectAltLocAtom	mypro.cpp	/^int SelectAltLocAtom(Atom* totalAtom, int &cntTotalAtom, FILE* fpPDBFile, char **metalEleList \/*= NULL *\/, int numMetalEle \/* = 0*\/, bool isSelectMetal \/* = false*\/)     \/*{{{*\/$/;"	f
SeqMatchAlign_Protein	mypro.cpp	/^int SeqMatchAlign_Protein(const char *Xstr, const char* Ystr, char *title1,char* title2,char* alignXstr0, char* alignYstr0,int* alignRel0,FILE *fpout, bool isPrintToScreen )\/*{{{*\/$/;"	f
Set2Array	mytemplate.h	/^template <class T, class InputIterator> void Set2Array(InputIterator __First, InputIterator __Last, T *array)\/*{{{*\/$/;"	f
Shuffle	myfunc.cpp	/^void Shuffle(int *array, int n, unsigned int rand_seed \/*= time(NULL)*\/)\/*{{{*\/$/;"	f
SigmoidScore	myfunc.cpp	/^double SigmoidScore(double a, double b, double x)\/*{{{*\/$/;"	f
SmoothImage	myfunc.cpp	/^void SmoothImage(unsigned short **image, int imageWidth, int imageHeight, int sizeN \/*= 1*\/)\/*{{{*\/$/;"	f
SortUniqueResidue	mypro.cpp	/^void SortUniqueResidue(GistPredChain *pChain, int operation)\/*{{{*\/$/;"	f
SpanExcluding	myfunc.cpp	/^char *SpanExcluding(const char* strForSpan,char* strAfterSpan, const char charSet[]\/*=WHITE_SPACE*\/)\/*{{{*\/$/;"	f
SplitFasta	splitfasta.cpp	/^void SplitFasta(const char* seqDataFile, const char *outpath, const char *ext)\/*{{{*\/$/;"	f
StdElementName	mypro.cpp	/^char* StdElementName(const char* elementName, char *stdElementName)\/*{{{*\/$/;"	f
StdID	mypro.cpp	/^char* StdID(char* id)\/*{{{*\/$/;"	f
StdPDBFileName2PDBID	mypro.cpp	/^char *StdPDBFileName2PDBID(const char* rtname_pdbfilename, char *pdbid)\/*{{{*\/$/;"	f
StdRegExp	mypro.cpp	/^void StdRegExp(char* pattern)\/*{{{*\/$/;"	f
Stdid2Seqresid	mypro.cpp	/^char* Stdid2Seqresid(char* id)\/*{{{*\/$/;"	f
Sum	mytemplate.h	/^template <class T> T Sum(T *array, int low, int high)\/*{{{*\/$/;"	f
Swap	mytemplate.h	/^template <class T> void Swap(T& x1, T& x2)\/*{{{*\/$/;"	f
Swap	mytemplate.h	/^template <class T> void Swap(T* x1, T* x2)\/*{{{*\/$/;"	f
TRUE	Constant.h	22;"	d
TranScore	mypro.cpp	/^double TranScore(double ***M,Residue* res,char *alphabet, int numRes)\/*{{{*\/$/;"	f
TransMatrixWeight	mypro.cpp	/^double TransMatrixWeight(Residue * pRes1, Residue * pRes2)\/*{{{*\/$/;"	f
TreatAllZeroFij	mypro.cpp	/^void TreatAllZeroFij(int **fij, int length, double *score1, char *aaSeq, const char* alphabet)\/*{{{*\/$/;"	f
UILDSEQMAP	Makefile	/^export BUILDSEQMAP := ${PWD}\/..$/;"	m
UNKNOWN_3CharAA	mypro.cpp	/^const char UNKNOWN_3CharAA[]= "UNK";$/;"	v
UNKNOWN_AA	mypro.h	127;"	d
UNKNOWN_DSSP_SEC	mypro.h	129;"	d
UNKNOWN_SEQ_TYPE	myfunc.h	76;"	d
UNKNOWN_SHAPE	mypro.h	128;"	d
UP	mypro.h	97;"	d
USE_AVERAGE	mypro.h	64;"	d
USE_MAXIMUM	mypro.h	65;"	d
UpdateHCRes	mypro.cpp	/^int UpdateHCRes(Residue *HCRes, int &numRes, int *idx, int numSHCRRes)\/*{{{*\/$/;"	f
VERTICAL	mypro.h	90;"	d
V_NUMRES	createseqmap.cpp	43;"	d	file:
V_NUMRES	createseqmap.cpp	44;"	d	file:
V_NUMRES	getseqresseq.cpp	22;"	d	file:
VerifyFolder	myfunc.cpp	/^void VerifyFolder(const char* folder)\/*{{{*\/$/;"	f
WHITE_SPACE	Constant.h	38;"	d
WRITE_FILE_ERROR	Constant.h	54;"	d
WriteAlignment	mypro.cpp	/^void WriteAlignment(const char* title1,const char* title2,const char* aXstr,const char* aYstr, int* aRel, int length, int lineLength,FILE* fpout, int outmode \/*= HORIZONTAL *\/)\/*{{{*\/$/;"	f
WriteAlignmentHeader	mypro.cpp	/^void WriteAlignmentHeader(float gapOpen, float gapExt, AlignFactor *pAlignFactor, char *title1, char *title2, int m, int n, FILE *fpout)\/*{{{*\/$/;"	f
WriteBinaryFragInt5	mypro.cpp	/^int WriteBinaryFragInt5(const char *outfile, int fragFileType, char **idList, int numID, int maxSizeID, int length, short *posTar, short *numCan, int totalFragCan, FragCanInt5 *fragCan)\/*{{{*\/$/;"	f
WriteBinaryFragInt6	mypro.cpp	/^int WriteBinaryFragInt6(const char *outfile, int fragFileType, char **idList, int numID, int maxSizeID, int length, short *posTar, short *numCan, int totalFragCan, FragCanInt6 *fragCan)\/*{{{*\/$/;"	f
WriteBinaryFragShort5	mypro.cpp	/^int WriteBinaryFragShort5(const char *outfile, int fragFileType, char **idList, int numID, int maxSizeID, int length, short *posTar, short *numCan, int totalFragCan, FragCanShort5 *fragCan)\/*{{{*\/$/;"	f
WriteBinaryFragShort6	mypro.cpp	/^int WriteBinaryFragShort6(const char *outfile, int fragFileType, char **idList, int numID, int maxSizeID, int length, short *posTar, short *numCan, int totalFragCan, FragCanShort6 *fragCan)\/*{{{*\/$/;"	f
WriteBinaryMODM	mypro.cpp	/^template <class T> int WriteBinaryMODM(const char *outfile, char *alphabet, int length, T * profile, double *parameter, int8 typeProfile)\/*{{{*\/$/;"	f
WriteCHDE	mypro.cpp	/^void WriteCHDE(FILE *fpout, char *id, int *speResIndex, int numSpeRes, int *resIndex, int numRes, MODM *pMODM, bool isWriteHeader \/*= true*\/, bool isWriteCounter \/*= false*\/)\/*{{{*\/$/;"	f
WriteCHDEComment	mypro.cpp	/^void WriteCHDEComment(FILE *fpout)\/*{{{*\/$/;"	f
WriteCloseMetalRes	mypro.cpp	/^void WriteCloseMetalRes(FILE* fpout, Residue* res, int numRes)\/*{{{*\/$/;"	f
WriteFastaSeq	mypro.cpp	/^void WriteFastaSeq(char *str, FILE *fpout \/*=stdout*\/,int beg\/* = 0*\/ , int end \/*= 0x7FFFFFFF*\/ , int linelength  \/*= 70*\/)\/*{{{*\/$/;"	f
WriteMODMProfile	mypro.cpp	/^void WriteMODMProfile(int index, char aa, int* V, double score1, double score2,const char* alphabet, FILE* fpout \/*= stdout*\/ )\/*{{{*\/$/;"	f
WriteMODMTitle	mypro.cpp	/^void WriteMODMTitle(const char* alphabet, FILE* fpout \/*= stdout*\/ )\/*{{{*\/$/;"	f
WriteMetalEnvRes	mypro.cpp	/^void WriteMetalEnvRes(FILE* fpMetalEnvShape, AtomEnv* pAtomEnv, bool isPrintDebugInfo \/* = false*\/)\/*{{{*\/$/;"	f
WritePDBAtomRecord	mypro.cpp	/^void WritePDBAtomRecord(Atom *pAtom, FILE *fpout\/* = stdout*\/ )\/*{{{*\/$/;"	f
WritePredictStat	mypro.cpp	/^void WritePredictStat(FILE* fp,  int ReP, int ReN, int PrP, int PrN, int TP, int FP, int TN, int FN, double Sn, double Sp,int ReP1,int ReN1, int ReP2,int  ReN2,double cutoff_consv,int cutoff_window,char* resList, bool isWriteHeader \/*= false*\/)\/*{{{*\/$/;"	f
WriteResRecord3	mypro.cpp	/^void WriteResRecord3(char *str, Residue *pRes, int tag)\/*{{{*\/$/;"	f
WriteSubMatrix	mypro.cpp	/^void WriteSubMatrix(FILE* fpSubMatrix, double** subM, int dim,  char* alphabet,int *cnt, char formatValue[] \/*= "%4.0lf"*\/, char formatFreq[] \/*= "%7d"*\/)\/*{{{*\/$/;"	f
WriteVectorRecordID	mypro.cpp	/^void WriteVectorRecordID(char *vectorRecordID, char *rmtID, int length, int idx, char *res_1char_list,int* aaSeqIndex, int numSite)\/*{{{*\/$/;"	f
ZnBindingProtein	mypro.cpp	/^namespace ZnBindingProtein$/;"	n	file:
ZnBindingProtein	mypro.h	/^namespace ZnBindingProtein$/;"	n
_ASSERT_	mypro.h	13;"	d
_CONST_E	Constant.h	87;"	d
_CONST_G	Constant.h	89;"	d
_CONST_Na	Constant.h	92;"	d
_CONST_PI	Constant.h	86;"	d
_CONST_atm	Constant.h	91;"	d
_CONST_c	Constant.h	90;"	d
_CONST_h	Constant.h	88;"	d
_TCHAR	Constant.h	47;"	d
_TCHAR	Constant.h	49;"	d
__int16	DataType.h	/^typedef int16      __int16;  $/;"	t
__int32	DataType.h	/^typedef int32      __int32;$/;"	t
__int64	DataType.h	/^typedef int64      __int64;$/;"	t
__int8	DataType.h	/^typedef int8       __int8;$/;"	t
__unit16	DataType.h	/^typedef unit16     __unit16;$/;"	t
__unit32	DataType.h	/^typedef unit32     __unit32;$/;"	t
__unit64	DataType.h	/^typedef unit64     __unit64;$/;"	t
__unit8	DataType.h	/^typedef unit8      __unit8;$/;"	t
_int16	DataType.h	/^typedef int16       _int16;$/;"	t
_int32	DataType.h	/^typedef int32       _int32;$/;"	t
_int64	DataType.h	/^typedef int64       _int64;$/;"	t
_int8	DataType.h	/^typedef int8        _int8;$/;"	t
_strupr	shapestring.cpp	13;"	d	file:
_unit16	DataType.h	/^typedef unit16      _unit16;$/;"	t
_unit32	DataType.h	/^typedef unit32      _unit32;$/;"	t
_unit64	DataType.h	/^typedef unit64      _unit64;$/;"	t
_unit8	DataType.h	/^typedef unit8       _unit8;$/;"	t
aa	mypro.h	/^	char       aa;           \/\/ 1 letter amini acid name$/;"	m	struct:DSSP_Residue
aa	mypro.h	/^	char aa;                 \/\/ one letter residue name$/;"	m	struct:Residue
aa	mypro.h	/^    char  aa;$/;"	m	struct:Profile
aa	mypro.h	/^    char  aa;$/;"	m	struct:ProfileByte
aa	mypro.h	/^    char  aa;$/;"	m	struct:ProfileSAD
aa	mypro.h	/^    char  aa;$/;"	m	struct:ProfileSADByte
aaSeq	mypro.h	/^    char    *aaSeq;$/;"	m	struct:MODM
aaSeq	mypro.h	/^    char   *aaSeq;$/;"	m	struct:GistPredChain
aaSeq	mypro.h	/^    char *aaSeq;      \/\/ amino acid sequence$/;"	m	struct:Chain
aaSeqIndex	mypro.h	/^	int  aaSeqIndex;         \/\/ residue sequence index number in SEQRES$/;"	m	struct:Residue
aaSeqIndex	mypro.h	/^    int    *aaSeqIndex;$/;"	m	struct:GistPredChain
aaSeqIndex	mypro.h	/^    int   aaSeqIndex;$/;"	m	struct:Profile
aaSeqIndex	mypro.h	/^    int   aaSeqIndex;$/;"	m	struct:ProfileSAD
aaSeqIndex	mypro.h	/^    short   aaSeqIndex;$/;"	m	struct:ProfileByte
aaSeqIndex	mypro.h	/^    short   aaSeqIndex;$/;"	m	struct:ProfileSADByte
acc	mypro.h	/^	int        acc;          \/\/ solvent accessibility,ACC$/;"	m	struct:DSSP_Residue
alnSeq	mypro.h	/^    char **alnSeq;   \/\/ size= numSeq*seqlength , aligned sequence with gaps$/;"	m	struct:MSA
alnSeqLen	mypro.h	/^    int *alnSeqLen;  \/\/ size=numSeq;$/;"	m	struct:MSA
alnSeqName	mypro.h	/^    char **alnSeqName; \/\/record name for each sequence$/;"	m	struct:MSA
alpha	mypro.h	/^	float      alpha;        \/\/ virtual torsion angle (dihedral angle) defined by the four C-alpha atoms of residues I-1,I,I+1,I+2$/;"	m	struct:DSSP_Residue
alphabetMODM	mypro.h	/^    char    *alphabetMODM;$/;"	m	struct:MODM
altLoc	mypro.h	/^	char   altLoc;        \/\/ Alternate location indicator$/;"	m	struct:Atom
array	array.h	/^	T* array;$/;"	m	class:Array2D_Sub
array1D	array.h	/^        T* array1D; \/\/ can also accessed by array1D directory, quicker$/;"	m	class:Array1D
array2D	array.h	/^		Array2D_Sub& array2D;$/;"	m	class:Array2D_Sub::Row
array2D	array.h	/^        T** array2D;$/;"	m	class:Array2D
array3D	array.h	/^        T*** array3D;$/;"	m	class:Array3D
atom	mypro.h	/^	Atom *atom;$/;"	m	struct:Residue
atomCnt	mypro.h	/^	int atomCnt;$/;"	m	struct:AtomFreq
atomEnv	mypro.h	/^	AtomEnv *atomEnv;       \/\/ atomEnv for this protein$/;"	m	struct:MetalPro
atomEnv	mypro.h	/^    AtomEnv *atomEnv;$/;"	m	struct:MetalPro2
atomName	mypro.h	/^	char atomName[4];$/;"	m	struct:AtomFreq
atomNum	mypro.h	/^	int atomNum;   \/\/ element atomic number$/;"	m	struct:Element
bBridge1	mypro.h	/^	char       bBridge1;     \/\/ beta bridge lable$/;"	m	struct:DSSP_Residue
bBridge2	mypro.h	/^	char       bBridge2;     \/\/ beta bridge lable$/;"	m	struct:DSSP_Residue
bSheet	mypro.h	/^	char       bSheet;       \/\/ beta sheet lable$/;"	m	struct:DSSP_Residue
binarysearch	mytemplate.h	/^template <class T> int binarysearch(T key, T *array, int n)\/*{{{*\/$/;"	f
bp1	mypro.h	/^	int        bp1;          \/\/ beta bridge partner resnum$/;"	m	struct:DSSP_Residue
bp2	mypro.h	/^	int        bp2;          \/\/ beta bridge partner resnum$/;"	m	struct:DSSP_Residue
cf	mypro.h	/^	int       cf;       \/\/ fold id number$/;"	m	struct:SCOP
chainBreak	mypro.h	/^	char       chainBreak;$/;"	m	struct:DSSP_Residue
chainID	mypro.h	/^	char       chainID;$/;"	m	struct:DSSP_Residue
chainID	mypro.h	/^	char      chainID;                               \/\/chain id, e.g A$/;"	m	struct:SCOP
chainID	mypro.h	/^	char   chainID;       \/\/ chainID$/;"	m	struct:Atom
chainID	mypro.h	/^	char chainID;$/;"	m	struct:Residue
chainID	mypro.h	/^    char  chainID;    \/\/ chain ID$/;"	m	struct:Chain
chainIDs	mypro.h	/^	char chainIDs[NUM_CHAIN_PER_DOMAIN+1];$/;"	m	struct:DomainDEF
charge	mypro.h	/^	char   charge[SIZE_ATOM_CHARGE+1];     \/\/ charge on the atom$/;"	m	struct:Atom
checkfilestream	myfunc.cpp	/^int checkfilestream(FILE *fp, const char* filename, const char *mode, bool isAssert \/*=false*\/)\/*{{{*\/$/;"	f
chira	mypro.h	/^	char       chira;        \/\/ chirality$/;"	m	struct:DSSP_Residue
cl	mypro.h	/^	int       cl;       \/\/ class id number$/;"	m	struct:SCOP
cls	mypro.h	/^	char      cls;      \/\/ class id, e.g. a, in a.60.6.1$/;"	m	struct:SCOP
colSize	array.h	/^	unsigned int colSize;$/;"	m	class:Array2D_Sub
colSize	array.h	/^        unsigned int colSize;$/;"	m	class:Array2D
combin2	subset.cpp	/^int combin2 ( int n, int k )\/*{{{*\/$/;"	f
consv	mypro.h	/^	double  consv;           \/\/ conservation level of the residue according to PSSM$/;"	m	struct:Residue
consv	mypro.h	/^    DATATYPE_CONSV  *consv;      \/\/ conservation level$/;"	m	struct:Chain
consv	mypro.h	/^    double  *consv;  \/\/conservation level for certain residues, say CHDE$/;"	m	struct:MODM
did	mypro.h	/^	char      did[SIZE_SCOP_ID+1];                   \/\/ domain id, e.g d9icwa1$/;"	m	struct:SCOP
discriminant	mypro.h	/^    double *discriminant;\/\/ discriminant for each residue$/;"	m	struct:GistPredChain
dist	mypro.h	/^    double *dist;         \/\/ record the distance of this atom to other atoms$/;"	m	struct:Atom
dm	mypro.h	/^	int       dm;       \/\/ domain id number$/;"	m	struct:SCOP
domDef	mypro.h	/^	DomainDEF domDef;   \/\/ parsered domain definition$/;"	m	struct:SCOP
domainDef	mypro.h	/^	char      domainDef[SIZE_DOMAIN_DEF_RECORD+1];   \/\/ string for domain record definition, e.g. A:205-298$/;"	m	struct:SCOP
dsspSec	mypro.h	/^    char    *dsspSec;$/;"	m	struct:MODM
dsspSec	mypro.h	/^    char  dsspSec;$/;"	m	struct:ProfileSAD
dsspSec	mypro.h	/^    char  dsspSec;$/;"	m	struct:ProfileSADByte
e	mypro.h	/^	double e;     \/\/ electric energy$/;"	m	struct:DSSP_HBond
eValue	mypro.h	/^	double eValue;$/;"	m	struct:AlignFactor
element	mypro.h	/^	char   element[SIZE_ATOM_ELEMENT+1];    \/\/ element symbol$/;"	m	struct:Atom
f_neglect_clustalw_header	mypro.cpp	/^void f_neglect_clustalw_header(FILE *fp)\/*{{{*\/$/;"	f
f_neglect_comment	myfunc.cpp	/^void f_neglect_comment(FILE* fp, const char comment_char \/*= '#'*\/)\/*{{{*\/$/;"	f
fa	mypro.h	/^	int       fa;       \/\/ family id number$/;"	m	struct:SCOP
fam	mypro.h	/^	int       fam;      \/\/ family id, e.g. 1 in a.60.6.1$/;"	m	struct:SCOP
fgetdelim	myfunc.cpp	/^int fgetdelim(FILE* fp, char* str, const char* delim \/* = WHITE_SPACE*\/, int max\/* = 0x7FFFFFFF*\/)\/*{{{*\/$/;"	f
fgetline	myfunc.cpp	/^int fgetline(FILE* fp, char* line, int max\/* = 0x7FFFFFFF*\/)\/*{{{*\/$/;"	f
fgetlinecnt	myfunc.cpp	/^int fgetlinecnt(FILE* fp, bool is_count_black_line \/*= true*\/)\/*{{{*\/$/;"	f
fgetlinecnt	myfunc.cpp	/^int fgetlinecnt(const char* filename, bool is_count_black_line \/*= true*\/)\/*{{{*\/$/;"	f
fgetlinecnt	myfunc.cpp	/^int fgetlinecnt(const char* filename, int &maxline, bool is_count_blank_line \/*= true*\/)\/*{{{*\/$/;"	f
fgetlinesize	myfunc.cpp	/^int fgetlinesize(FILE* fp)\/*{{{*\/$/;"	f
fod	mypro.h	/^	int       fod;      \/\/ fold id, e.g. 60 in a.60.6.1$/;"	m	struct:SCOP
gapExt	createseqmap.cpp	/^int gapExt   = -1;$/;"	v
gapOpen	createseqmap.cpp	/^int gapOpen  = -7;$/;"	v
gapPercent	mypro.h	/^	float gapPercent;$/;"	m	struct:AlignFactor
gap_cnt	mypro.h	/^	int   gap_cnt;$/;"	m	struct:AlignFactor
gaplessSeqIndex	mypro.h	/^    int **gaplessSeqIndex; \/\/size= numSeq *seqLength,  indexing for the alnSeq, only non gap residues are counted, gaps set to DIGIT_INDEL$/;"	m	struct:MSA
geoBend	mypro.h	/^	char       geoBend;      \/\/ geometrical bend$/;"	m	struct:DSSP_Residue
getfileext	myfunc.cpp	/^char *getfileext(const char* filename, char *ext, int max_ext \/*= MAX_PATH *\/)\/*{{{*\/$/;"	f
getfilepath	myfunc.cpp	/^char *getfilepath(const char* filename, char *path, int max_path \/*= MAX_PATH *\/)\/*{{{*\/$/;"	f
hbond	mypro.h	/^	DSSP_HBond hbond[4];     \/\/ h-bond$/;"	m	struct:DSSP_Residue
iCode	mypro.h	/^	char       iCode;        \/\/ iCode in PDB File$/;"	m	struct:DSSP_Residue
iCode	mypro.h	/^	char   iCode;         \/\/ Code for insertion of residues$/;"	m	struct:Atom
i_max	subset.cpp	/^int i_max ( int i1, int i2 )\/*{{{*\/$/;"	f
i_min	subset.cpp	/^int i_min ( int i1, int i2 )\/*{{{*\/$/;"	f
icodeF	mypro.h	/^    char icodeF[NUM_CHAIN_PER_DOMAIN+1]; \/\/ icode for the start position$/;"	m	struct:DomainDEF
icodeT	mypro.h	/^    char icodeT[NUM_CHAIN_PER_DOMAIN+1]; \/\/ icode for the end position$/;"	m	struct:DomainDEF
id	mypro.h	/^	char     id[SIZE_CHAIN_ID+1];\/\/ chain identifier of nrPDB we are looking for$/;"	m	struct:AtomEnv
id	mypro.h	/^    char     id[SIZE_CHAIN_ID+1];$/;"	m	struct:MODM
id	mypro.h	/^    char    id[SIZE_CHAIN_ID+1];$/;"	m	struct:GistPredChain
id	mypro.h	/^    char id[SIZE_CHAIN_ID+1];      \/\/nrPDBb chain identifier$/;"	m	struct:MetalBindPro
id	mypro.h	/^    char id[SIZE_CHAIN_ID+1];$/;"	m	struct:MetalPro
id	mypro.h	/^    char id[SIZE_CHAIN_ID+1];$/;"	m	struct:MetalPro2
id	mypro.h	/^    char id[SIZE_CHAIN_ID+1];$/;"	m	struct:PredPro
id	mypro.h	/^    char id[SIZE_CHAIN_ID+1];$/;"	m	struct:SSBondPro
identity	mypro.h	/^	float identity;$/;"	m	struct:AlignFactor
identity_short	mypro.h	/^	float identity_short;$/;"	m	struct:AlignFactor
idnum	mypro.h	/^	int       idnum;    \/\/ domain id number, e.g. 17982$/;"	m	struct:SCOP
idt_cnt	mypro.h	/^	int   idt_cnt;$/;"	m	struct:AlignFactor
idxInner	mypro.h	/^    int idxInner; \/*id index within the frag file.*\/$/;"	m	struct:FragCanInt5
idxInner	mypro.h	/^    int idxInner; \/*id index within the frag file.*\/$/;"	m	struct:FragCanInt6
idxInner	mypro.h	/^    short idxInner; \/*id index within the frag file.*\/$/;"	m	struct:FragCanShort5
idxInner	mypro.h	/^    short idxInner; \/*id index within the frag file.*\/$/;"	m	struct:FragCanShort6
idxOuter	mypro.h	/^    int idxOuter; \/*id index for the external supplied id list*\/$/;"	m	struct:FragCanInt6
idxOuter	mypro.h	/^    short idxOuter; \/*id index for the external supplied id list*\/$/;"	m	struct:FragCanShort6
int16	DataType.h	/^typedef signed short        int16;$/;"	t
int32	DataType.h	/^typedef signed int          int32;$/;"	t
int64	DataType.h	/^typedef signed long long    int64;$/;"	t
int8	DataType.h	/^typedef signed char         int8;$/;"	t
intensity	shapestring.cpp	/^    unit8 intensity;$/;"	m	struct:PointDef	file:
isBioMetalBound	mypro.h	/^	bool isBioMetalBound;    \/\/ if the residue is biologic-ally metal bound$/;"	m	struct:Residue
isBound	mypro.h	/^    bool isBound;$/;"	m	struct:MetalBindPro
isChainIDCaseSensitive	shapestring.cpp	/^bool isChainIDCaseSensitive = true; \/*by default the chainID is case sensitive*\/$/;"	v
isForceRunDSSP	shapestring.cpp	/^bool isForceRunDSSP = false;$/;"	v
isInterChain	mypro.h	/^    bool    isInterChain;   \/\/ interChain or intraChain$/;"	m	struct:SSBond
isPrintAlignment	createseqmap.cpp	/^bool isPrintAlignment = false;$/;"	v
isPrintDNASeq	getseqresseq.cpp	/^bool isPrintDNASeq = false;$/;"	v
isUsingPDBAtom	shapestring.cpp	/^bool isUsingPDBAtom = false;$/;"	v
isWholeChain	mypro.h	/^	bool isWholeChain[NUM_CHAIN_PER_DOMAIN];   \/\/ whether the SCOP domain including a while chain$/;"	m	struct:DomainDEF
ivec_indicator	subset.cpp	/^void ivec_indicator ( int n, int a[] )\/*{{{*\/$/;"	f
kappa	mypro.h	/^	float      kappa;        \/\/ virtual bond angle (bend angle) defined by the three C-alpha atoms of residues I-2,I,I+2.$/;"	m	struct:DSSP_Residue
ksub_next	subset.cpp	/^void ksub_next ( int n, int k, int a[], bool *more )\/*{{{*\/$/;"	f
ksub_next2	subset.cpp	/^void ksub_next2 ( int n, int k, int a[], int *in, int *iout )\/*{{{*\/$/;"	f
ksub_next3	subset.cpp	/^void ksub_next3 ( int n, int k, int a[], bool *more, int *in, int *iout )\/*{{{*\/$/;"	f
ksub_next4	subset.cpp	/^void ksub_next4 ( int n, int k, int a[], bool *done )\/*{{{*\/$/;"	f
label	mypro.h	/^    int    *label;$/;"	m	struct:GistPredChain
length	mypro.h	/^    char length;$/;"	m	struct:SSBondPro
length	mypro.h	/^    int      length;$/;"	m	struct:MODM
length	mypro.h	/^    int     length;     \/\/ total number of residues of pdb chain$/;"	m	struct:GistPredChain
length	mypro.h	/^    int length;             \/\/ length of the protein sequence$/;"	m	struct:MetalPro
length	mypro.h	/^    int length;$/;"	m	struct:MetalPro2
locate_range	mytemplate.h	/^template <class T> int locate_range(T key, T *array, int lo, int hi)\/*{{{*\/$/;"	f
log2	myfunc.h	108;"	d
log_M	mypro.h	/^    DATATYPE_MODM_MATRIX    **log_M; \/\/log(Mij), this is used when profile-profile alignment is needed, the log(Mij) is precalculated to save the computational time, in that case, Mij should be weighted percentage$/;"	m	struct:MODM
main	createseqmap.cpp	/^int main(int argc, char** argv)\/*{{{*\/$/;"	f
main	getdsspfilepath.cpp	/^int main(int argc , char** argv)\/*{{{*\/$/;"	f
main	getpdbaafilepath.cpp	/^int main(int argc , char** argv)\/*{{{*\/$/;"	f
main	getpdbfilepath.cpp	/^int main(int argc , char** argv)\/*{{{*\/$/;"	f
main	getseqresseq.cpp	/^int main(int argc, char** argv)\/*{{{*\/$/;"	f
main	shapestring.cpp	/^int main( int argc, char *argv[])\/*{{{*\/$/;"	f
main	splitfasta.cpp	/^int main(int argc, char** argv)\/*{{{*\/$/;"	f
match	createseqmap.cpp	/^int match    = 5;$/;"	v
maxConsv	mypro.h	/^    DATATYPE_CONSV  maxConsv;   \/\/maximal conservation for keyAA$/;"	m	struct:MetalBindPro
max_element	mytemplate.h	/^template <class T> T max_element(T *array, int lo, int hi)\/*{{{*\/$/;"	f
max_element_index	mytemplate.h	/^template <class T> int max_element_index(T *array, int lo, int hi)\/*{{{*\/$/;"	f
maxline	splitfasta.cpp	/^int maxline = 10000;$/;"	v
metalAtomChainID	mypro.h	/^	char     metalAtomChainID;    \/\/ chainID annotation for the metal atom in PDB file$/;"	m	struct:AtomEnv
metalAtomList	mypro.h	/^    char **metalAtomList;   \/\/ list of all bound metal atoms in the chain, just listing, not unique$/;"	m	struct:MetalPro
metalAtomName	mypro.h	/^	char     metalAtomName[SIZE_METAL_ATOM_NAME+1];         \/\/ metal atom element symbol$/;"	m	struct:AtomEnv
metalAtomPDBID	mypro.h	/^    char     metalAtomPDBID[SIZE_PDBID+1];$/;"	m	struct:AtomEnv
metalAtomResName	mypro.h	/^	char     metalAtomResName[SIZE_METAL_ATOM_RES_NAME+1];  \/\/ residue name of metal atom, for example "HEM"$/;"	m	struct:AtomEnv
metalAtomResSeq	mypro.h	/^    int      metalAtomResSeq;  \/\/ residue serial number for metalAtom  in PDB, 2007-04-19$/;"	m	struct:AtomEnv
misMatch	createseqmap.cpp	/^int misMatch = -10;$/;"	v
module	DataType.h	/^	double module;$/;"	m
my_strcpy	myfunc.cpp	/^int my_strcpy(char* to, const char* from, int max)\/*{{{*\/$/;"	f
my_strlwr	myfunc.cpp	/^char *my_strlwr(char* str, int beg \/* =0*\/, int end \/*= 0x7FFFFFFF*\/)\/*{{{*\/$/;"	f
my_strupr	myfunc.cpp	/^char *my_strupr(char* str, int beg \/* = 0*\/, int end \/* = 0x7FFFFFFF*\/)\/*{{{*\/$/;"	f
name	mypro.h	/^	char   name[SIZE_ATOM_NAME+1];       \/\/ atom name$/;"	m	struct:Atom
name	mypro.h	/^	char name[SIZE_ATOM_ELEMENT+1] ; \/\/ element name$/;"	m	struct:Element
nonMetalHetGroup	mypro.cpp	/^const char *nonMetalHetGroup[] =\/*{{{*\/$/;"	v
numAtom	mypro.h	/^	int  numAtom ;$/;"	m	struct:Residue
numBoundRes	mypro.h	/^    int numBoundRes;        \/\/ number of bound Residues$/;"	m	struct:MetalPro
numChain	mypro.h	/^	int  numChain;                             \/\/ number of chains, here chain might be the segment of a single chain, for example d1hcz_1 1-167,231-250, there are two segments;$/;"	m	struct:DomainDEF
numDist	mypro.h	/^    int    numDist;       \/\/ number of distances$/;"	m	struct:Atom
numMetalAtom	mypro.h	/^    int numMetalAtom;         \/\/ number of metal atoms bound to the polypeptide chain$/;"	m	struct:MetalPro2
numMetalAtom	mypro.h	/^    int numMetalAtom;       \/\/ number of metal atoms for the protein$/;"	m	struct:MetalPro
numMetalBound	mypro.h	/^    int  numMetalBound;      \/\/ number of metals bound to the residue, for co-catalytic zinc, one Asp can bind to two metal atoms$/;"	m	struct:Residue
numNonMetalHetGroup	mypro.cpp	/^int numNonMetalHetGroup = 60;$/;"	v
numRes	mypro.h	/^	int      numRes;           \/\/ number of residues included in the atomEnv, for example including only residues on a single chain$/;"	m	struct:AtomEnv
numRes	mypro.h	/^    int     numRes;         \/\/ in case of interchain ssbond, sometimes it will be 1$/;"	m	struct:SSBond
numRes	mypro.h	/^    int     numRes;     \/\/ number of residues in GistPredChain, might not be equal to the length of the chain$/;"	m	struct:GistPredChain
numRes	mypro.h	/^    int   numRes;     \/\/ residue number$/;"	m	struct:Chain
numRes	mypro.h	/^    int numRes;$/;"	m	struct:PredPro
numSSBond	mypro.h	/^    int numSSBond;$/;"	m	struct:SSBondPro
numSSBondRes	mypro.h	/^    int numSSBondRes;$/;"	m	struct:SSBondPro
numSeq	mypro.h	/^    int numSeq;$/;"	m	struct:MSA
numSpeRes	mypro.h	/^    int numSpeRes;$/;"	m	struct:PredPro
occupancy	mypro.h	/^	float  occupancy;     \/\/ occupancy$/;"	m	struct:Atom
operator []	array.h	/^		T& operator [] (unsigned int col) const$/;"	f	class:Array2D_Sub::Row
operator []	array.h	/^	Row operator [] (unsigned int row) {return Row(*this,row);}$/;"	f	class:Array2D_Sub
operator []	array.h	/^template <class T> T& Array1D<T>::operator [] (unsigned int i) { return array1D[i]; }$/;"	f	class:Array1D
option_parser_filename	myfunc.cpp	/^int option_parser_filename(int argc, char **argv, int beg, char *filename)\/*{{{*\/$/;"	f
option_parser_numeric	myfunc.cpp	/^template <class T> int option_parser_numeric(int argc, char **argv, int beg, T &x, bool isRangeSet \/*= false*\/, T min \/*= MIN_INT*\/, T max \/*= MAX_INT*\/)\/*{{{*\/$/;"	f
origName	mypro.h	/^	char   origName[SIZE_ATOM_ORIGNAME+1];   \/\/ record the four columns in ATOM record$/;"	m	struct:Atom
p	mypro.h	/^    float p[20];$/;"	m	struct:Profile
p	mypro.h	/^    float p[20];$/;"	m	struct:ProfileSAD
p	mypro.h	/^    int8 p[20];$/;"	m	struct:ProfileByte
p	mypro.h	/^    int8 p[20];$/;"	m	struct:ProfileSADByte
parentAtomEnvIndex	mypro.h	/^	int *parentAtomEnvIndex; \/\/ used only when res is a mmeber of MetalPro, usually the size of parentAtomEnvIndex = 1$/;"	m	struct:Residue
parentResIndex	mypro.h	/^    int     *parentResIndex;    \/\/ used only when atomEnv is a member of MetalPro$/;"	m	struct:AtomEnv
pdbid	mypro.h	/^	char      pdbid[SIZE_PDBID+1];                   \/\/ pdbid, e.g 9icw$/;"	m	struct:SCOP
pdbid	mypro.h	/^    char  pdbid[SIZE_PDBID+1];$/;"	m	struct:Chain
pha	DataType.h	/^	double pha;$/;"	m
phi	mypro.h	/^	float      phi;          \/\/ IUPAC peptide backbone torsion angles$/;"	m	struct:DSSP_Residue
phi	mypro.h	/^    float *phi;       \/\/ phi torsion angle$/;"	m	struct:Chain
pid	mypro.h	/^    float *pid; \/\/percent identity of the shorter sequence, to the keyseqence, key sequence is the sequence with id Query, otherwise the first sequence.$/;"	m	struct:MSA
pos	mypro.h	/^	int    pos;   \/\/ positon of hydrogen bond$/;"	m	struct:DSSP_HBond
posCan	mypro.h	/^    int posCan;   \/*position of the candidate fragment in sequence*\/$/;"	m	struct:FragCanInt5
posCan	mypro.h	/^    int posCan;   \/*position of the candidate fragment in sequence*\/$/;"	m	struct:FragCanInt6
posCan	mypro.h	/^    short posCan;   \/*position of the candidate fragment in sequence*\/$/;"	m	struct:FragCanShort5
posCan	mypro.h	/^    short posCan;   \/*position of the candidate fragment in sequence*\/$/;"	m	struct:FragCanShort6
posF	mypro.h	/^	int  posF[NUM_CHAIN_PER_DOMAIN];           \/\/ start position in the sequence$/;"	m	struct:DomainDEF
posT	mypro.h	/^	int  posT[NUM_CHAIN_PER_DOMAIN];           \/\/ end position in the sequence$/;"	m	struct:DomainDEF
pozScore	mypro.h	/^	float pozScore;$/;"	m	struct:AlignFactor
printLineLength	shapestring.cpp	/^int printLineLength = 60; \/*maximum length of each line to print out the shape string*\/$/;"	v
psi	mypro.h	/^	float      psi;          \/\/ IUPAC peptide backbone torsion angles$/;"	m	struct:DSSP_Residue
psi	mypro.h	/^    float *psi;       \/\/ psi torsion angle$/;"	m	struct:Chain
px	mypro.h	/^	int       px;       \/\/$/;"	m	struct:SCOP
readfloatfromfile	shapestring.cpp	/^float readfloatfromfile(char *bak,int k1,int k2)\/*{{{*\/$/;"	f
readintfromfile	shapestring.cpp	/^int readintfromfile(char *bak,int k1,int k2)\/*{{{*\/$/;"	f
recordID	mypro.h	/^    char   recordID[SIZE_RECORD_ID+1];$/;"	m	struct:Atom
reg_findall	myfunc.cpp	/^int reg_findall(const char* string, const char* pattern,  regmatch_t * pmatch ,bool isOverlap \/*= false*\/)\/*{{{*\/$/;"	f
res	mypro.h	/^	Residue *res;$/;"	m	struct:AtomEnv
res	mypro.h	/^    Residue *res;           \/\/ residues binding to metals for this protein$/;"	m	struct:MetalPro
res	mypro.h	/^    Residue res[2];$/;"	m	struct:SSBond
resICode	mypro.h	/^	char resICode;           \/\/insertion code$/;"	m	struct:Residue
resICode	mypro.h	/^    char *resICode;   \/\/ reside insertion code array$/;"	m	struct:Chain
resName	mypro.h	/^	char   resName[SIZE_RES_NAME+1];    \/\/ 3-letter residue name$/;"	m	struct:Atom
resName	mypro.h	/^	char resName[SIZE_RES_NAME+1];$/;"	m	struct:Residue
resSeq	mypro.h	/^	int        resSeq;       \/\/ resSeq in PDB File$/;"	m	struct:DSSP_Residue
resSeq	mypro.h	/^	int    resSeq;        \/\/ residue sequence number ;$/;"	m	struct:Atom
resSeq	mypro.h	/^	int  resSeq;             \/\/residue sequential number in ATOM record$/;"	m	struct:Residue
resSeqIndex	mypro.h	/^	int *resSeqIndex;       \/\/ array of aaSeqIndex for residues binding to metals for this protein$/;"	m	struct:MetalPro
resSeqIndex	mypro.h	/^    int  *resSeqIndex;$/;"	m	struct:PredPro
resSer	mypro.h	/^    int  *resSer;     \/\/ residue serial number (in ATOM record) array$/;"	m	struct:Chain
rootname	myfunc.cpp	/^char *rootname(const char* filename, char* rtname, int max_rtname \/*= MAX_PATH*\/)\/*{{{*\/$/;"	f
row	array.h	/^		unsigned int const row;$/;"	m	class:Array2D_Sub::Row
rowSize	array.h	/^	unsigned int rowSize;$/;"	m	class:Array2D_Sub
rowSize	array.h	/^        unsigned int rowSize;$/;"	m	class:Array2D
score	mypro.h	/^	float score;$/;"	m	struct:AlignFactor
score	mypro.h	/^    float score;    \/*score of the candidate fragment to the target fragment*\/$/;"	m	struct:FragCanInt5
score	mypro.h	/^    float score;    \/*score of the candidate fragment to the target fragment*\/$/;"	m	struct:FragCanInt6
score	mypro.h	/^    float score;    \/*score of the candidate fragment to the target fragment*\/$/;"	m	struct:FragCanShort5
score	mypro.h	/^    float score;    \/*score of the candidate fragment to the target fragment*\/$/;"	m	struct:FragCanShort6
score1	mypro.h	/^    double  *score1;$/;"	m	struct:MODM
score1	mypro.h	/^    float score1;$/;"	m	struct:Profile
score1	mypro.h	/^    float score1;$/;"	m	struct:ProfileByte
score1	mypro.h	/^    float score1;$/;"	m	struct:ProfileSAD
score1	mypro.h	/^    float score1;$/;"	m	struct:ProfileSADByte
score2	mypro.h	/^    double  *score2;$/;"	m	struct:MODM
score2	mypro.h	/^    float score2;$/;"	m	struct:Profile
score2	mypro.h	/^    float score2;$/;"	m	struct:ProfileByte
score2	mypro.h	/^    float score2;$/;"	m	struct:ProfileSAD
score2	mypro.h	/^    float score2;$/;"	m	struct:ProfileSADByte
secStruc	mypro.h	/^    char *secStruc;   \/\/ secondary structure$/;"	m	struct:Chain
segID	mypro.h	/^	char   segID[SIZE_ATOM_SEGID+1];      \/\/ segment identifier$/;"	m	struct:Atom
seqLen	mypro.h	/^    int *seqLen; \/\/size = numSeq, without gaps$/;"	m	struct:MSA
seqLength	mypro.h	/^	int      seqLength;          \/\/ length of the seqence of that chain$/;"	m	struct:AtomEnv
seqResSer	mypro.h	/^	int        seqResSer;    \/\/ sequential residue number$/;"	m	struct:DSSP_Residue
seqtype	mypro.h	/^    int8  seqtype;    \/*sequence type, AA_SEQ: amino acid seq, DNA_SEQ: nucleic acid seq, SHAPE_SEQ: shape strings*\/$/;"	m	struct:Chain
serial	mypro.h	/^	int    serial;        \/\/ atom serial number$/;"	m	struct:Atom
sf	mypro.h	/^	int       sf;       \/\/ superfamily id number$/;"	m	struct:SCOP
shString	mypro.h	/^    char    *shString;$/;"	m	struct:MODM
shString	mypro.h	/^    char *shString;   \/\/ shapeString;$/;"	m	struct:Chain
shape	mypro.h	/^	char shape;$/;"	m	struct:Residue
shape	mypro.h	/^    char  shape;$/;"	m	struct:ProfileSAD
shape	mypro.h	/^    char  shape;$/;"	m	struct:ProfileSADByte
sim_cnt	mypro.h	/^	int   sim_cnt;$/;"	m	struct:AlignFactor
similarity	mypro.h	/^	float similarity;$/;"	m	struct:AlignFactor
similarity_short	mypro.h	/^	float similarity_short;$/;"	m	struct:AlignFactor
size	array.h	/^        unsigned int size;$/;"	m	class:Array1D
sizeAAalpabet	shapestring.cpp	/^int sizeAAalpabet = 22;$/;"	v
sp	mypro.h	/^	int       sp;       \/\/ species id number$/;"	m	struct:SCOP
speResSeqIndex	mypro.h	/^    int  *speResSeqIndex;$/;"	m	struct:PredPro
sreplace	myfunc.cpp	/^char *sreplace(char* to, char* from, int start \/*= 0*\/)\/*{{{*\/$/;"	f
ss	mypro.h	/^	char       ss;           \/\/ secondary structure lable$/;"	m	struct:DSSP_Residue
ssbond	mypro.h	/^    SSBond *ssbond;$/;"	m	struct:SSBondPro
ssubstitute	myfunc.cpp	/^char *ssubstitute(char* str, char chForSub, char chAfterSub, int start \/*= 0*\/, int end \/*= 0x7FFFFFFF *\/)\/*{{{*\/$/;"	f
strchomp	myfunc.cpp	/^char *strchomp(char *str)\/*{{{*\/$/;"	f
strltrim	myfunc.cpp	/^char *strltrim(char *str, const char *trim \/*= " \\t\\n\\r"*\/)\/*{{{*\/$/;"	f
strrtrim	myfunc.cpp	/^char *strrtrim(char *str, const char *trim \/*= " \\t\\n\\r"*\/)\/*{{{*\/$/;"	f
strtrim	myfunc.cpp	/^char *strtrim(char *str, const char *trim \/*= " \\t\\n\\r"*\/)\/*{{{*\/$/;"	f
strupr	shapestring.cpp	12;"	d	file:
sup	mypro.h	/^	int       sup;      \/\/ superfamily id, e.g. 6 in a.60.6.1$/;"	m	struct:SCOP
tco	mypro.h	/^	float      tco;          \/\/ cosine of angle between C=O of residue I and C=O of residue I-1$/;"	m	struct:DSSP_Residue
tempFactor	mypro.h	/^	float  tempFactor;    \/\/ temperature factor$/;"	m	struct:Atom
title	mypro.h	/^    char  *title;     \/*title of the sequence, e.g. the annotations in the PDB file, 2008-02-06*\/$/;"	m	struct:Chain
totalBoundRes	mypro.h	/^    int      totalBoundRes;    \/\/ number of all residues in the protein bind to the metal, 2007-04-19$/;"	m	struct:AtomEnv
turn3	mypro.h	/^	char       turn3;        \/\/ 3 turn helix$/;"	m	struct:DSSP_Residue
turn4	mypro.h	/^	char       turn4;        \/\/ 4 turn helix$/;"	m	struct:DSSP_Residue
turn5	mypro.h	/^	char       turn5;        \/\/ 5 turn helix$/;"	m	struct:DSSP_Residue
type_modm	mypro.h	/^    int      type_modm;$/;"	m	struct:MODM
uniform_random	myfunc.cpp	/^double uniform_random(double min \/*= 0.0*\/, double max \/*= 1.0*\/)\/*{{{*\/$/;"	f
unit16	DataType.h	/^typedef unsigned short      unit16;$/;"	t
unit32	DataType.h	/^typedef unsigned int        unit32;$/;"	t
unit64	DataType.h	/^typedef unsigned long long  unit64;$/;"	t
unit8	DataType.h	/^typedef unsigned char       unit8;$/;"	t
usage	classify-seqid.awk	/^function usage(e1)$/;"	f
usage	id2pdbid.awk	/^function usage(e1)$/;"	f
usage	scopid2stdid.awk	/^function usage(e1)$/;"	f
waterAcc	mypro.h	/^    int     *waterAcc;$/;"	m	struct:MODM
waterAcc	mypro.h	/^    int   waterAcc;$/;"	m	struct:ProfileSAD
waterAcc	mypro.h	/^    int  *waterAcc;   \/\/ water accessibility$/;"	m	struct:Chain
waterAcc	mypro.h	/^    int8   waterAcc;$/;"	m	struct:ProfileSADByte
x	DataType.h	/^	double x;$/;"	m
x	mypro.h	/^	double x;             \/\/ x coordinate$/;"	m	struct:Atom
x	mypro.h	/^	float      x;            \/\/ Ca x coordinate$/;"	m	struct:DSSP_Residue
x	shapestring.cpp	/^    unit8 x;$/;"	m	struct:PointDef	file:
xSize	array.h	/^        unsigned int xSize;$/;"	m	class:Array3D
y	DataType.h	/^	double y;$/;"	m
y	mypro.h	/^	double y;             \/\/ y coordinate$/;"	m	struct:Atom
y	mypro.h	/^	float      y;            \/\/ Ca y coordinate$/;"	m	struct:DSSP_Residue
y	shapestring.cpp	/^    unit8 y;$/;"	m	struct:PointDef	file:
ySize	array.h	/^        unsigned int ySize;$/;"	m	class:Array3D
z	mypro.h	/^	double z;             \/\/ z coordinate$/;"	m	struct:Atom
z	mypro.h	/^	float      z;            \/\/ Ca z coordinate$/;"	m	struct:DSSP_Residue
zScore	mypro.h	/^	float zScore;$/;"	m	struct:AlignFactor
zSize	array.h	/^        unsigned int zSize;$/;"	m	class:Array3D
~Array1D	array.h	/^template <class T> Array1D<T>::~Array1D(void) \/*{{{*\/$/;"	f	class:Array1D
~Array2D	array.h	/^template <class T> Array2D<T>::~Array2D(void)\/*{{{*\/$/;"	f	class:Array2D
~Array2D_Sub	array.h	/^	~Array2D_Sub()$/;"	f	class:Array2D_Sub
~Array3D	array.h	/^template <class T> Array3D<T>::~Array3D(void)\/*{{{*\/$/;"	f	class:Array3D
